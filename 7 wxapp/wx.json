{"title": "使用gulp构建微信小程序开发工作流 ", "author": "Rolan", "time": "2020-3-25 00:36", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    web开发基本上都是基于webpack或者其他的构建工具来进行开发，大大节约了开发者的时间。目前的微信小程序开发也有很多开源的框架可供选择，但是如果使用原生开发模式，虽然可以完美使用小程序原生的新特性和功能，但是工作流角度上却十分简陋。19年末的时候公司要开发一个新的小程序，组里面的大佬同事提议使用gulp来构建下原生开发模式的工作流。一是为了摆脱简陋的工作流模式以节约开发时间，二是也是把技术用到刀刃上。在大佬的指导开发下，这个工作便进行了。总体来说这个工作并不难，增益可能也没有那么大，但是还是收获了很多。项目地址： gulp-mp工作流改进我们把开发目录设置在 src ，输出目录设置在 dist ，定义开发与输出路径。文件复制微信小程序的page目录通常包含 wxml , json , wxss 和 js 文件，与原生开发模式不同的是我们使用 sass 预处理器来写样式，其他的文件保持原样不同。因此，对于 wxml , json , js 文件来说，仅仅需要copy就行。因为在项目中已经配置了 eslint+prettier 来进行语法检查和代码美化，因此不需要在工作流的js代码进行规范检查。如果没有配置，可以安装 gulp-eslint 执行eslint规范检查。const srcPath = \"./src/**\";\r\nconst distPath = \"./dist/\";\r\nconst wxmlFiles = [`${srcPath}/*.wxml`];\r\nconst jsFiles = [`${srcPath}/*.js`, `!${srcPath}/env/*.js`];\r\nconst jsonFiles = [`${srcPath}/*.json`];\r\n\r\n// copy wxml\r\nconst wxml = () => {\r\n  return gulp\r\n    .src(wxmlFiles, { since: gulp.lastRun(wxml) })\r\n    .pipe(gulp.dest(distPath));\r\n};\r\ngulp.task(wxml);\r\n\r\n// 其他copy流类似\r\n...\r\n复制代码sass处理上面我们提到使用 sass 预处理来编写样式，在输出的时候我们需要把 scss 样式转换成 wxss， wxss 就是普通的 css 样式。这里，我们使用 gulp-sass 插件转换scss样式。但是，需要注意的是在 scss 文件中，我们可能会import相关样式，可能是公共样式也可能是varibale和minxin。经过测试发现，当import公共样式，会把这个公共样式打包进当前页面。我们知道小程序的包是有大小限制的，如果在引入公共样式的时候还打包到当前页面，无疑是消耗掉了不必要的内存。所以，针对公共样式的import处理为，不交给sass处理，保留import并把后缀的.scss改成.wxss。当import的是变量和mixin时，我们需要保留对其的sass处理，因此新建独立的目录存放以便识别。在这一场景下，变量和mixin的文件不再递归处理。//存放variable和mixin的sass文件在被引用时直接导入，不引入dist目录中\r\nconst DIRECTIMPORT = [\"/scss/\", \"/font/\"];\r\nconst sassFiles = [`${srcPath}/*.{scss, wxss}`];\r\n\r\nconst wxss = () => {\r\n  return gulp\r\n    .src([...sassFiles, ...DIRECTIMPORT.map(item => `!${srcPath}/${item}/*`)], {\r\n      since: gulp.lastRun(wxss)\r\n    })\r\n    .pipe(plumber({ errorHandler: onError }))\r\n    .pipe(\r\n      tap(file => {\r\n        const filePath = path.dirname(file.path);\r\n        //console.log(\"filepath\", filePath);\r\n        file.contents = new Buffer(\r\n            // 匹配@import\r\n          String(file.contents).replace(\r\n            /@import\\s+['|\"](.+)['|\"];/g,\r\n            ($1, $2) => {\r\n              console.log(\"$1\", $1);\r\n              console.log(\"$2\", $2);\r\n              //如果不是变量或者mixin则注释掉\r\n              return DIRECTIMPORT.some(item => {\r\n                return $2.indexOf(item) > -1;\r\n              })\r\n                ? $1\r\n                : `/** ${$1} **/`;\r\n            }\r\n          )\r\n        );\r\n      })\r\n    )\r\n    .pipe(sass())\r\n    .pipe(postcss([autoprefixer([\"iOS >= 8\", \"Android >= 4.1\"])]))\r\n    .pipe(\r\n      replace(/(\\/\\*\\*\\s{0,})(@.+)(\\s{0,}\\*\\*\\/)/g, ($1, $2, $3) => {\r\n        //console.log(\"$1\", $1);\r\n        //console.log(\"$2\", $2);\r\n        //console.log(\"$3\", $3);\r\n        //去掉注释并修改scss后缀为wxss\r\n        return $3.replace(/\\.scss/g, \".wxss\");\r\n      })\r\n    )\r\n    .pipe(rename({ extname: \".wxss\" }))\r\n    .pipe(gulp.dest(distPath));\r\n};\r\ngulp.task(wxss);\r\n复制代码压缩图片文件安装gulp-imagemin插件压缩图片。之前通过npm安装在使用的时候这个插件总是报错，后来发现是没有正确安装，瞎倒腾切换到cnpm或者yarn发现可以安装成功了。const imageFiles = [\r\n  `${srcPath}/images/*.{png,jpg,gif,ico}`,\r\n  `${srcPath}/images/**/*.{png,jpg,gif,ico}`\r\n];\r\nconst img = () => {\r\n  return gulp\r\n    .src(imageFiles, { since: gulp.lastRun(img) })\r\n    .pipe(imagemin())\r\n    .pipe(gulp.dest(distPath));\r\n};\r\ngulp.task(img);\r\n复制代码区分开发环境正常开发过程中，开发，测试和发布环境通常会有不同的API接口和其他设置。在每次切换的时候手动去更改内部代码是一件很麻烦的事情，也容易遗忘，根据不同的命令自动加载相应的开发环境设置才是我们想要的效果。 在 src/env/* 目录下，配置了三个环境的变量： dev.js ， test.js ， prod.js 。const envJs = env => {\r\n  return () => {\r\n    return gulp\r\n      .src(`./src/env/${env}.js`)\r\n      .pipe(rename(\"env.js\"))\r\n      .pipe(gulp.dest(distPath));\r\n  };\r\n};\r\ngulp.task(envJs);\r\n复制代码清除dist目录在重新编译的时候我们都需要清除dist目录的资源，以免导致混乱/* 清除dist目录 */\r\ngulp.task(\"clean\", done => {\r\n  del.sync([\"dist/**\"]);\r\n  done();\r\n});\r\n复制代码自动创建目录使用命令新建page目录和component目录，只要把模版文件拷贝并重命名即可。const newfile = done => {\r\n  yargs\r\n    .example(\"gulp newfile  -p mypage\", \"创建mypage的page目录\")\r\n    .example(\"gulp newfile  -c mycomponent\", \"创建mycomponent的component目录\")\r\n    .example(\r\n      \"gulp newfile  -s srcfile -p mypage\",\r\n      \"以srcfile为模版创建mypage的page目录\"\r\n    )\r\n    .option({\r\n      s: {\r\n        alias: \"src\",\r\n        describe: \"模板\",\r\n        type: \"string\",\r\n        default: \"template\"\r\n      },\r\n      p: {\r\n        alias: \"page\",\r\n        describe: \"page名称\",\r\n        type: \"string\"\r\n      },\r\n      c: {\r\n        alias: \"component\",\r\n        describe: \"component名称\",\r\n        type: \"string\"\r\n      }\r\n    })\r\n    .fail(msg => {\r\n      done();\r\n      console.error(\"创建失败\");\r\n      console.log(msg);\r\n      console.log(\"help\");\r\n      yargs.parse([\"--msg\"]);\r\n    })\r\n    .help(\"msg\");\r\n\r\n  const args = yargs.argv;\r\n  //console.log(\"args\", args);\r\n  const source = args.s;\r\n  const filePaths = {\r\n    p: \"pages\",\r\n    c: \"components\"\r\n  };\r\n\r\n  let name,\r\n    type,\r\n    hasParam = false;\r\n  for (let key in filePaths) {\r\n    if (args[key]) {\r\n      hasParam = true;\r\n      name = args[key];\r\n      type = filePaths[key];\r\n    }\r\n  }\r\n  if (!hasParam) {\r\n    done();\r\n    yargs.parse([\"--msg\"]);\r\n  }\r\n  const defaultPath =\r\n    source === \"template\"\r\n      ? `src/${source}/${type}/*`\r\n      : `src/${type}/${source}/*`;\r\n  return gulp.src(defaultPath).pipe(gulp.dest(`src/${type}/${name}/`));\r\n};\r\ngulp.task(newfile);\r\n复制代码 \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "简单说说微信小程序的底层原理 ", "author": "Rolan", "time": "2019-11-19 00:12", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    小程序选择了 Hybrid 的渲染方式，将UI渲染跟 JavaScript 的脚本执行分在了两个线程。双线程模型小程序的渲染层和逻辑层分别由两个线程管理：渲染层：界面渲染相关的任务全都在\tWebView 线程里执行。一个小程序存在多个界面，所以渲染层存在多个\tWebView 线程。逻辑层：采用\tJsCore 线程运行JS脚本，在这个环境下执行的都是有关小程序业务逻辑的代码。双线程之间的通信我们都知道小程序是避免DOM操作，而是采用数据驱动来渲染页面的，那么他到底是怎么通过更改数据来更新DOM呢。逻辑层和渲染层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。通过把 WXML 转化为数据，通过 Native 进行转发，来实现逻辑层和渲染层的交互和通信。在渲染层会把WNML转化成Js对象，Js对象会模拟DOM树逻辑层更新数据的时候，通过setData方法将数据从逻辑层转发到Native,Native再转发到渲染层这时候，比较两虚拟DOM树的差异，最后将差异应用到真实DOM树上，更新页面。Virtual DOM 相信大家都已有了解，大概是这么个过程：用JS对象模拟DOM树 -> 比较两棵虚拟DOM树的差异 -> 把差异应用到真正的DOM树上。小程序的生命周期小程序的生命周期借鉴了Android的生命周期，如果你了解过Android的APP开发，那么理解小程序的就会很简单。界面线程有四大状态：初始化状态：初始化界面线程所需要的工作，包括工作机制，基本和我们开发者没有关系，等初始化完毕就向“服务线程”发送初始化完毕信号，然后进入等待传回初始化数据状态。首次渲染状态：收到“服务线程”发来的初始化数据后（就是 json和js中的data数据），就开始渲染小程序界面，渲染完毕后，发送“首次渲染完毕信号”给服务线程，并将页面展示给用户。持续渲染状态：此时界面线程继续一直等待“服务线程”通过this.setdata（）函数发送来的界面数据，只要收到就重新局部渲染，也因此只要更新数据并发送信号，界面就自动更新。结束状态：结束渲染。服务线程五大状态：初始化状态：无需和其他模块交流，跟小程序开发也没多大关联，此阶段就是启动服务线程所需的基本功能，比如信号发送模块。系统的初始化工作完毕，就调用自定义的onload和onshow， 然后等待界面线程的“界面线程初始化完成”信号。onload是只会首次渲染的时候执行一次，onshow是每次界面切换都会执行，简单理解，这就是唯一差别。等待激活状态：接收到“界面线程初始化完成”信号后，将初始化数据发送给“界面线程”，等待界面线程完成初次渲染。激活状态：收到界面线程发送来的“首次渲染完成”信号后，就进入激活状态既程序的正常运行状态，并调用自定义的onReady()函数。此状态下就可以通过 this.setData 函数发送界面数据给界面线程进行局部渲染，更新页面。后台运行状态：如果界面进入后台，服务线程就进入后台运行状态，从目前的官方解读来说，这个状态挺奇怪的，和激活状态是相同的，也可以通过setdata函数更新界面的。毕竟小程序的框架刚推出，应该后续会有很大不同吧。运行机制启动热启动：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动；冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即冷启动。销毁只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。更新机制开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户。小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。所以如果想让用户使用最新版本的小程序，可以利用\twx.getUpdateManager 做个检查更新的功能。 \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "使用Taro小程序框架开发一个学习做题聊天交流的微信小程序 ", "author": "Rolan", "time": "2019-11-19 00:41", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    项目介绍当代大学生上课缺少积极性，学习缺乏效率。同为大学生的我深有体会。所以特别开发出这样一款学习类的微信小程序帮助学生进行学习、巩固知识，同时增加对战PK模块来加强学生们的学习积极性。这是一个为学生提供在线学习课程、题库练习、考试答题、做题PK、上课签到、资料查阅、成绩分析等功能的微信小程序希望大佬们走过路过给个star~技术选型前端：Taro + 微信小程序 + Echarts后端：Node.js + MySql + websocket其他：七牛云存储项目功能在线学习课程专项题库练习课程考试答题知识趣味竞赛上课签到系统专业资料查阅学生成绩分析运行截图1. 主页2. 个人中心3. 课程详情4. 做题练习5. 学习交流群6. 聊天室7. 课程列表8. 习题列表9. 排行榜10. 论坛项目分析项目采用前后端分离的技术，前端采用了Taro微信小程序框架，因为本人比较喜欢React，所以采用了Taro这款类React语法的框架，后端则采用了Node.js,koa2框架。聊天室页面采用websocket来进行连接今天，我们首先来聊一聊聊天室使用的小技巧（并不）首先我们的后端数据库采用的是mysql，我们建了一个聊天记录的表（萌新勿喷~）1. 后端部分数据库部分我们将所有的聊天记录存放到一张表上方便管理，因为我们有多个聊天群组，我们该如何区分这些不同的聊天群组呢？答案是，通过room_name来区分，获取聊天记录的时候就直接查询这个群组名即可，这样就不用开很多的表，将不同的群聊记录存放到不同的表中啦！同时因为我们的聊天记录内需要存储emoji等信息，所以，我们需要将数据库的字符集调整为 utf8mb4 -- UTF-8 Unicode ，排序规则选择 utf8mb4_unicode_ci ，这个可以通过自行百度，或者navicat中设置。然后我们将数据表以及字段类型也设置为 utf8mb4 ，便于存储emoji信息后端处理聊天记录的方法。router.get('/chatlog/:to', async (ctx) => {\r\n  const to = ctx.params.to\r\n  const response = []\r\n  const res = await query(`SELECT * FROM chatlog WHERE room_name = '${to}' ORDER BY current_time DESC`);\r\n  res.map((item, index) => {\r\n    const { room_name, user_name, user_avatar, current_time, message } = item\r\n    response[index] = {\r\n      to: room_name,\r\n      userName: user_name,\r\n      userAvatar: user_avatar,\r\n      currentTime: formatTime(current_time),\r\n      message,\r\n      messageId: `msg${current_time}${Math.ceil(Math.random() * 100)}`\r\n    }\r\n  })\r\n  ctx.response.body = parse(response)\r\n})这是获取指定群聊的后端接口，to代表的是群组名，使用get的方法即可获取到指定群聊的聊天记录啦！继续聊聊我们如何为所有连接到聊天室的网友们发送信息，这里我们采用的是广播的方式，不同于socket.io内已经封装好广播的方法，小程序规定只能使用websocket，所以我粗略的封装了一下广播（十分丑陋的代码）let onlineUserSocket = {}\r\nlet onlineUserInfo = {}\r\n\r\nconst handleLogin = (ws, socketMessage) => {\r\n  const { socketId, userName, userAvatar } = socketMessage\r\n  onlineUserSocket[socketId] = ws\r\n  onlineUserInfo[socketId] = { userName, userAvatar }\r\n  ws.socketId = socketId\r\n}\r\n\r\n// 广播消息\r\nconst broadcast = (message) => {\r\n  const { from, userName } = message\r\n  Object.values(onlineUserSocket).forEach((socket) => {\r\n    socket.send(JSON.stringify({\r\n      ...message,\r\n      isMyself: userName === onlineUserInfo[socket.socketId].userName\r\n    }))\r\n  })\r\n}我们再登录的时候，就将前端传来的消息存入对象中，以及他的socket对象，然后广播的时候就可以遍历所有的socket对象，为所有在线用户广播消息，其中的 isMyself 代表的是否为本人，例如我发的消息，自己的socket对象接受广播的时候就是 true 。别人的就是 false ，这样做是为了方便区分，自己的聊天消息和被人的聊天消息2. 前端部分接下来聊聊前端的聊天室部分handleSocketMessage(): void {\r\n    const { socketTask } = this\r\n    socketTask.onMessage(async ({ data }) => {\r\n      const messageInfo: ReceiveMessageInfo = JSON.parse(data)\r\n      const { to, messageId, isMyself, userName, userAvatar, currentTime, message } = messageInfo\r\n      const time: string = formatTime(currentTime)\r\n\r\n      this.messageList[to].push({\r\n        ...messageInfo,\r\n        currentTime: time\r\n      })\r\n      /* 设置群组最新消息 */\r\n      this.contactsList.filter(contacts => contacts.contactsId === to)[0].latestMessage = {\r\n        userName, message, currentTime: time\r\n      }\r\n      this.scrollViewId = isMyself ? messageId : ''\r\n      await Taro.request({\r\n        url: 'http://localhost:3000/chatlog',\r\n        method: 'PUT',\r\n        data: {\r\n          to,\r\n          userName,\r\n          userAvatar,\r\n          currentTime,\r\n          message,\r\n        }\r\n      })\r\n    })\r\n  }我们先接受消息，然后先更新指定群组名的聊天群组的聊天记录，然后再使用 PUT 的方式访问接口添加聊天记录到数据库中。可以看到我们的聊天记录是分为左边以及右边的，自己发的消息即为右边，我们可以通过简单的flex布局来实现// 这里是覆盖默认样式，显示自己消息的样式\r\n.myself {\r\n  justify-content: flex-end;\r\n\r\n  .avatar {\r\n    order: 1;\r\n  }\r\n\r\n  .info {\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: flex-end;\r\n\r\n    .header {\r\n      justify-content: flex-end;\r\n\r\n      .username {\r\n        order: 1;\r\n        margin-right: 0 !important;\r\n        margin-left: .5em;\r\n      }\r\n    }\r\n\r\n    .content {\r\n      color: #333 !important;\r\n      border: #e7e7e7 1px solid;\r\n      background: #fff !important;\r\n      box-shadow: 0 8px 20px -8px #d7d7d7;\r\n    }\r\n  }\r\n}\r\n\r\n// 以下是默认样式，就是左边的样式\r\n.message-wrap {\r\n  display: flex;\r\n  margin: 20px 0;\r\n\r\n  .avatar {\r\n    width: 14vw;\r\n    height: 14vw;\r\n    margin: 10px;\r\n    border-radius: 50%;\r\n    background-image: linear-gradient(120deg, #a1c4fd 0%, #c2e9fb 100%);\r\n  }\r\n\r\n  .info {\r\n\r\n    .header {\r\n      display: flex;\r\n      align-items: center;\r\n      max-width: 40vw;\r\n      padding: 10px 0;\r\n      color: #666;\r\n      font-size: .8em;\r\n\r\n      .username {\r\n        overflow: hidden;\r\n        text-overflow: ellipsis;\r\n        white-space: nowrap;\r\n        max-width: 40vw;\r\n        margin-right: .5em;\r\n        color: #555;\r\n        font-size: 1.2em;\r\n        font-weight: bold;\r\n      }\r\n    }\r\n\r\n    .content {\r\n      display: inline-block;\r\n      max-width: 60vw;\r\n      padding: 10px 20px;\r\n      color: #fff;\r\n      word-break: break-all;\r\n      border-radius: 20px;\r\n      background: #66a6ff;\r\n    }\r\n  }\r\n}最后我们聊一下websocket的断线重连handleSocketClose(): void {\r\n    const { socketTask } = this\r\n    socketTask.onClose((msg) => {\r\n      this.socketTask = null\r\n      this.socketReconnect()\r\n      console.log('onClose: ', msg)\r\n    })\r\n  }\r\n\r\n  handleSocketError(): void {\r\n    const { socketTask } = this\r\n    socketTask.onError(() => {\r\n      this.socketTask = null\r\n      this.socketReconnect()\r\n      console.log('Error!')\r\n    })\r\n  }我们这里先监听一下websocket关闭或者异常的情况，调用重连方法，以及清空socketTask的对象，接下来是重连的方法socketConnect() {\r\n    // 生成随机特有的socketId\r\n    this.generateSocketId()\r\n\r\n    /* 使用then的方法才能正确触发onOpen的方法，暂时不知道原因 */\r\n    Taro.connectSocket({\r\n      url: 'ws://localhost:3000',\r\n    }).then(task => {\r\n      this.socketTask = task\r\n      this.handleSocketOpen()\r\n      this.handleSocketMessage()\r\n      this.handleSocketClose()\r\n      this.handleSocketError()\r\n    })\r\n  }\r\n\r\n  socketReconnect(): void {\r\n    this.isReconnected = true\r\n    clearTimeout(this.timer)\r\n\r\n    /* 3s延迟重连，减轻压力 */\r\n    this.timer = setTimeout(() => {\r\n      this.socketConnect()\r\n    }, 3000)\r\n  }我们每三秒调用一遍socket连接的方法，重新再设置好socketId，以及socketTask，重新监听各种方法。这里有一个奇特的地方，就是Taro的connectSocket方法，不能使用 async/await 的方法来获取socketTask，也就是说不能这样 const socketTask = await Taro.connectSocket({...}) 来获取socketTask，只能通过then的方法才能获取到，卑微的我暂时不知道如何解决这个问题......具体后续请关注一下我的github，将持续更新项目！猛戳~ \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "开发|微信小程序与tensorflow.js准备工作 ", "author": "Rolan", "time": "2019-11-20 00:01", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    本文首发于微信公众号： \"算法与编程之美\"，欢迎关注，及时了解更多此系列文章。问题描述这篇文章主要讲解如何将 t ensorflow 与微信小程序结合，使得 t ensorflow 的模型能够在微信小程序上呈现出来。解决方案下载微信小程序稳定版，版本号最新的就行。新建一个小程序项目, AppID 必须是正式的没有可以注册一个。打开项目后点击右上角详情 — > 本地设置 - -> 调试基础库 -- > 选择最新版本并勾选使用 n pm 模块。打开以下网址，登录自己的小程序账号添加 t ensorflowJS 插件。安装 t ensorflowJS 库，安装 L TS 版本 ( 安装过程不需要配置，一直点下一步即可 )https://nodejs.org/en/安装成功后，打开 P owerShell( 管理员 ) ，如下图输入 node –version 和 npm –version 查看版本号检测是否安装成功接下来使用 n pm 安装 t fjs 所用的一些包先切换到小程序项目的目录下，输入 npm init 对环境进行初始化之后会要求输一些配置信息，没什么特别需求直接回车，最后输入 y es 即可分别安装以下包npm install @tensorflow/tfjs-corenpm install @tensorflow/tfjs-converternpm install fetch-wechat回到微信小程序页面，点击工具 -- > 构建 npm进入 p ackage.json 可以查看已经安装的包，每次新建项目都要重复初始化和安装包的操作删除一些微信小程序自带的代码， a pp.js 内的代码可以都删除。删除 Index.js 内的内容删除 l ogs 文件夹app.json 内指向 l ogs 的部分也删除 , 删除代码时前后相应的逗号别忘了删除，不然会报错。之后用代码导入包，进入之前添加 t ensorflowJS 插件的网页，下方有引入插件的代码及相关说明复制到 a pp . json 内，只复制红线部分复制红线内代码到 a pp.js之后用 t ensorflow 打印一个常量，检测是否能正常运行结语导入 tfjs 需要注意的地方基础库需要切换到2.7.0以上的版本（一般是最新版本）Npm 的初始化和安装需要在项目目录下操作每次安装 n pm 包之后，需要重新构建 n pmEND实习编辑   |   王文星责       编   |   马原涛 where2go 团队微信号： 算法与编程之美         \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "uni-app对微信小程序云函数的适配 ", "author": "Rolan", "time": "2019-11-20 00:05", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    版权说明本文首发于个人博客-指尖魔法屋（www.thinkmoon.cn)。原文地址： uni-app对微信小程序云函数的适配引言熟悉uni-app的人应该都知道，uni-app并未对微信小程序云函数（本文统称云函数）进行相应的适配。但是，如果我们在某些业务场景的下需要使用云函数呢？我们知道，云函数可以复制到微信开发者工具，这样的话我们不得不每次编译一次就手动复制一次，不得不说麻烦至极。本文就问题做出以下解决方案。本文环境Hbuilder X微信开发者工具创建云函数目录首先，我们需要在uni-app项目文件夹下，创建一个云函数目录，路径随意，我这里是 functions 。然后先随便在里面放一些文件，这里以 new_file.css 为例。修改 manifest.json在uni-app根目录下，修改 manifest.json 中的微信小程序项，结构如下\"mp-weixin\" : {\r\n        /* 小程序特有相关 */\r\n        \"appid\" : \"wxd7de467f6e6cf741\",\r\n        \"cloudfunctionRoot\": \"./functions/\", // 这一行就是标记云函数目录的字段\r\n        \"setting\" : {\r\n            \"urlCheck\" : false\r\n        },\r\n        \"usingComponents\" : true\r\n    }编写 vue.config.jsvue.config.js\r\nconst path = require('path')\r\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\r\n\r\nmodule.exports = {\r\n    configureWebpack: {\r\n        plugins: [\r\n            new CopyWebpackPlugin([\r\n                {\r\n                    from: path.join(__dirname, 'functions'),\r\n                    to: path.join(__dirname, 'unpackage/dist', process.env.NODE_ENV === 'production' ? 'build' : 'dev', process.env.UNI_PLATFORM, 'functions')\r\n                }\r\n            ])\r\n        ]\r\n    }\r\n}编译运行发现提示如下内容说明未安装 copy-webpack-plugin 插件，我们手动安装一下。然后编译运行，发现微信开发者工具里面出现以下内容。截止目前，已打通Hbuilder X到微信开发者工具的自动复制，即已解决本文的核心内容。以下为进一步测试。创建云函数我们在云函数根目录上右键，在右键菜单中，可以选择创建一个新的 Node.js 云函数，我们将该云函数命名为check。开发者工具在本地创建出云函数目录和入口 index.js 文件，同时在线上环境中创建出对应的云函数。创建成功后，工具会提示是否立即本地安装依赖，确定后工具会自动安装 wx-server-sdk。我们会看到以下内容。创建好后将其同步复制到uni-app项目，即可为以后自动同步行方便，又可避免在输出文件夹中云函数的意外丢失。至此，相关文件编写工作转至 Hbuilder X ，云函数上传部署依旧在微信开发者工具。编写云函数默认的云函数只是一个返回用户基本数据的内容，我们将其修改至满足我们的业务需求，以内容安全云调用为例。在云函数文件中写入以下内容// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async(event, context) => {\r\n  try {\r\n    console.log('待检测文本:' + event.content);\r\n    let result = await cloud.openapi.security.msgSecCheck({\r\n      content: event.content\r\n    })\r\n    console.log('result:' + JSON.stringify(result));\r\n\r\n    if (result && result.errCode.toString() === '87014') {\r\n      return {\r\n        code: 300,\r\n        msg: '内容含有违法违规内容',\r\n        data: result\r\n      }\r\n    } else {\r\n      return {\r\n        code: 200,\r\n        msg: 'ok',\r\n        data: result\r\n      }\r\n    }\r\n\r\n  } catch (err) {\r\n    if (err.errCode.toString() === '87014') {\r\n      return {\r\n        code: 300,\r\n        msg: '内容含有违法违规内容',\r\n        data: err\r\n      }\r\n    }\r\n    return {\r\n      code: 400,\r\n      msg: '调用security接口异常',\r\n      data: err\r\n    }\r\n  }\r\n}权限申明在函数目录下，创建一个 config.json ,文档说会自动创建，但是我实际操作时未自动创建。 config.json 内容如下。{\r\n    \"permissions\": {\r\n        \"openapi\": [\r\n            \"security.msgSecCheck\"\r\n        ]\r\n    }\r\n}然后在函数目录右键，上传并部署。小程序调用云函数wx.cloud.init()\r\n                wx.cloud.callFunction({\r\n                    name: 'check',\r\n                    data: {\r\n                        \"content\": this.contents.join()\r\n                    }\r\n                }).then(res => {\r\n                    console.log(res.result)\r\n                    if (res.result.code == 300) {\r\n                        uni.showModal({\r\n                            title: \"温馨提示\",\r\n                            content: \"你所输入的内容可能含有违法违规内容，不支持进行下一步操作\"\r\n                        })\r\n                        return\r\n                    } else {\r\n                        ... // 你要进行的操作\r\n                    }\r\n                })效果展示 \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "小程序 - 可搜索的地址选择 ", "author": "Rolan", "time": "2019-11-20 00:41", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    最终实现效果：新建index文件夹index.wxml<!--pages/index/index.wxml--><view class='container'>  <view bindtap='onChangeAddress'>    <input value=\"{{address}}\" name=\"address\" placeholder=\"选择地点\">  </view></view>index.js// pages/index/index.jsPage({  data: {    address: ''  },  onChangeAddress() {    var _page = this;    wx.chooseLocation({      success: (res) => {        _page.setData({          address: res.name        });      },      fail: (err) => {        console.log(err);      }    });  }})新建map文件夹map.wxml<!--pages/map/map.wxml--><view class=\"container\">  <map    id=\"myMap\"    style=\"width: 100%; height: 100%;\"    latitude=\"{{latitude}}\"    longitude=\"{{longitude}}\"    markers=\"{{markers}}\"    show-location  ></map></view>map.js// pages/map/map.jsPage({  data: {    latitude: 31.22786,    longitude: 121.46658,    markers: [{      id: 1,      latitude: 31.22786,      longitude: 121.46658,      name: '上海招商局广场'    }]  },  onReady(e) {    this.mapCtx = wx.createMapContext('myMap')  }}) \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "微信小程序 模拟打电话 实践 ", "author": "Rolan", "time": "2019-11-20 00:50", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    模拟电话模拟打电话功能，拨下指定的号码如10086，等待1.5秒后开始播放本地音频文件并计时。使用小程序官方API createInnerAudioContext()创建 InnerAudioContext对象。小程序官方推荐使用更为强大的音频上下文对象InnerAudioContext，官方已经停止了对组件的维护。上述这个demo效果的具体实现，如下代码：<template><view class=\"task\">  <view class=\"call\">    <!-- 顶部区域 -->    <view class=\"top\" wx:if=\"{{phone.length > 0}}\">      <view class=\"phone\">{{phone}}</view>      <view class=\"tip\" wx:if=\"{{calling}}\">        <view wx:if=\"{{tipShow}}\">正在呼叫...</view>        <view wx:else>{{formatMmSs}}</view>      </view>    </view>    <!-- 中间区域 -->    <view class=\"middle\">      <view class=\"nums\" wx:if=\"{{showNums}}\" @tap=\"numClick\">        <view class=\"row\">          <view class=\"num\" data-num='1'>1</view>          <view class=\"num\" data-num='2'>2</view>          <view class=\"num\" data-num='3'>3</view>        </view>        <view class=\"row\">          <view class=\"num\" data-num='4'>4</view>          <view class=\"num\" data-num='5'>5</view>          <view class=\"num\" data-num='6'>6</view>        </view>        <view class=\"row\">          <view class=\"num\" data-num='7'>7</view>          <view class=\"num\" data-num='8'>8</view>          <view class=\"num\" data-num='9'>9</view>        </view>        <view class=\"row\">          <view class=\"num\" data-num='*'>*</view>          <view class=\"num\" data-num='0'>0</view>          <view class=\"num\" data-num='#'>#</view>        </view>          </view>      <view class=\"icons\" wx:else>        <view class=\"icon\">          <image src=\"{{img.ringIcon1}}\"></image>          <view>静音</view>        </view>        <view class=\"icon\">          <image src=\"{{img.ringIcon2}}\" @tap=\"handle('back')\"></image>          <view>拔号</view>        </view>        <view class=\"icon\">          <image src=\"{{img.ringIcon3}}\"></image>          <view>免提</view>        </view>      </view>    </view>    <!-- 底部区域 -->    <view class=\"bottom\">      <image wx:if=\"{{!calling}}\" class=\"btn\" src=\"{{img.call}}\" @tap=\"handle('call')\"></image>      <image wx:else class=\"btn\" src=\"{{img.cancel}}\" @tap=\"handle('cancel')\"></image>      <image wx:if=\"{{!calling && phone.length>0}}\" class=\"del\" src=\"{{img.delete}}\" @tap=\"handle('delete')\"></image>    </view>  </view></view> </template><script>import wepy from 'wepy'import img from '@/assets'export default class Test extends wepy.page {  config = {    navigationBarTitleText: '模拟电话'  }  data = {    img: img,    phone: '',        // 10086    tipShow: false,   // 显示呼叫中    calling: false,   // 是否拔通电话    showNums: true,   // 显示数字面板    seconds: 0        // 计时  }  computed = {    // 通话计时 格式化    formatMmSs() {      return this.mmss(this.seconds)    }  }  // 格式化时间  mmss(count) {    count = count % 3600  // 不考虑 HH    let mm = Math.floor(count / 60)    let ss = count % 60    if (mm < 10) mm = '0' + mm    if (ss < 10) ss = '0' + ss    return mm + ':' + ss  }  onLoad() {    // 音频上下文    wepy.setInnerAudioOption({      mixWithOther: false,    // 终止其他应用或微信内的音乐      obeyMuteSwitch: false   // 在静音模式下，也能播放声音    })    let ctx = wepy.createInnerAudioContext()    ctx.src = '/assets/media/10086.mp3'    ctx.loop = true    ctx.onPlay(() => {      console.log('开始播放')    })    ctx.onError((res) => {      console.log(res.errMsg)    })    this.ctx = ctx  }  methods = {    // 点击数字    numClick(e) {      console.log(e)      console.log(e.target.dataset.num)      const num = e.target.dataset.num      this.phone = this.phone + num    },    handle(type) {      switch (type) {        case 'call':          // 拔打电话          if (this.phone !== '10086') {            wepy.showToast({ title: '请拔打10086', icon: 'none' })          } else {            this.calling = true            this.tipShow = true            // 延迟1.5秒后开始计时，并播放音频文件            setTimeout(() => {              this.ctx.play()              this.showNums = false              this.timer = setInterval(() => {                this.tipShow = false                this.seconds = this.seconds + 1                this.$apply()              }, 1000)            }, 1500)          }          break        case 'cancel':          // 挂掉电话          clearInterval(this.timer)          this.ctx.seek(0)          this.ctx.stop()          this.phone = ''          this.calling = false          this.showNums = true          this.seconds = 0          break        case 'delete':          // 删除电话号码的最后一位          let phone = this.phone          let arr = phone.split('')          arr.pop()          this.phone = arr.join('')          break        case 'back':          // 返回至数字键盘          this.showNums = true          break        default:          break      }    }  }}</script><style lang='less'>.task {  position: absolute;  top: 0;  bottom: 0;  left: 0;  right: 0;  overflow: hidden;  background: rgba(0, 0, 0, 1);  // 打电话区域  .call {    position: absolute;    top: 0;    right: 0;    bottom: 0;    left: 0;    z-index: 2;    .top {      position: absolute;      top: 48rpx;      left: 0;      right: 0;      color: #FDFDFD;      text-align: center;      .phone {        font-size: 72rpx;        line-height: 100rpx;      }      .tip {        font-size: 36rpx;        line-height: 54rpx;      }    }    .middle {      position: absolute;      top: 232rpx;      left: 0;      right: 0;      // 数字面板      .nums {        .row {          width: 540rpx;          margin: 0 auto;          height: 158rpx;          overflow: hidden;          .num {            float: left;            margin: 0 30rpx;            width: 120rpx;            height: 120rpx;            border-radius: 50%;            background:rgba(229,229,229,1);            text-align: center;            line-height: 120rpx;            font-size: 60rpx;            color: black;          }          .num:active {            background:rgba(229,229,229,0.5);          }        }      }      // 免提等      .icons {        margin: 0 auto;        width: 540rpx;        height: 250rpx;        overflow: hidden;        padding-top: 196rpx;        .icon {          float: left;          width: 120rpx;          margin: 0 30rpx;          &>image {            display: block;            width: 120rpx;            height: 120rpx;            border-radius: 50%;          }          &>image:active {            opacity: 0.7;          }          &>view {            font-size: 32rpx;            color: #FDFDFD;            text-align: center;            line-height: 68rpx;          }        }      }    }    .bottom {      position: absolute;      top: 940rpx;      left: 0;      right: 0;      text-align: center;      .btn {        display: inline-block;        width: 120rpx;        height: 120rpx;        border-radius: 50%;      }      .del {        display: inline-block;        width: 75rpx;        height: 56rpx;        position: absolute;        top: 46rpx;        right: 138rpx;      }      .btn:active {        opacity: 0.7;      }      .del:active {        opacity: 0.7;      }    }  }}</style> \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "在腾讯Q3财报中站C位的品牌小程序，BAT态度大不同！ ", "author": "Rolan", "time": "2019-11-22 00:12", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    昨天，腾讯2019年Q3财报如“约”而至。其中，小程序数据格外亮眼，不仅日活跃用户超过3亿，商业化也表现强劲，中长尾小程序日均商业交易笔数同比增加超过一倍。值得注意的是，这组数据中，“品牌”二字尤其“夺目”，财报显示：品牌自营类小程序数量同比增长1倍以上；8%的品牌自营类小程序交易额同比增长100倍以上、56%的品牌自营类小程序交易额同比增长50%以上，在头部领跑下，中腰部正在崛起；超过1亿人次访问品牌自营类小程序。这一定程度上说明了越来越多的品牌选择了微信小程序作为重要阵地。因此，要让用户在众多品牌中一眼就能发现自己，品牌曝光是首要环节。对于企业而言，如果没做好品牌曝光，自家品牌就会淹没在“芸芸众生”之中，而这一局面，在搜索场景下尤为突出。比如，用户输入一个关键词，结果“数不胜数”，无论用户看多少眼，也不一定会注意到。于是，BAT三巨头接踵而至地基于自家搜索推出一个能力：品牌主页。直白点说，“品牌主页”就是：在搜索结果页中，将企业各类信息与服务放在一起整体展示，比如企业认证信息、小程序、服务等等，入口更直接。微信“品牌主页”叫作品牌官方区，于去年4月基于搜一搜推出，在公众号后台便可开通；相比之下，支付宝与百度则慢了好几拍，都是最近才推出小程序能力，前者叫品牌直达，后者称百度品牌名片。虽然叫法不同（以下统称时，称为“品牌主页”），但其目的是一致的，都是为了帮助企业更好地建立品牌效应、将服务充分触达用户，从而提升收益。但BAT三平台的属性不同，“品牌主页”的能力开放程度、玩法等也有所差异，并非都能满足所有企业的需求，企业们在选择上也就“不知所云”。对此，晓程序观察（yinghoo-tech）就来一次测评与PK，帮助企业们选择适合自己的“品牌主页”。1流量曝光：微信品牌官方区完胜？既然“品牌主页”是用来帮助企业更好地触达用户，对于企业与品牌而言，最关心的还是流量，比如：用户输入哪些关键词，才能直达“品牌主页”？如果品牌名称输入错误，“品牌主页”能不能显示？“品牌主页”在搜索结果中是怎么排序的？实际上，对于搜索平台来说，这些都是影响流量曝光不可忽略的因素。流量曝光第一环：入口微信：三种样式、三种入口，A级最突出在搜一搜的搜索结果页中，微信品牌官方区的有三种展示样式，如图，依次为A、B、C三种：A级与B级的品牌官方区可以添加公众号、小程序、服务和商品；C级样式仅允许将公众号展示。此外，A级与B级都有品牌详情页，C级样式并没有。在众多搜索结果中，A级样式会有一种“鹤立鸡群”的感觉，更容易建立品牌认知，尤其是小程序、公众号、服务、商品等都是卡片形式，入口更加“抢眼”。不过，A级样式并不是所有品牌都能开通的，三种样式各有不同的门槛。如图，要求中包括公众号与官方区点击量、是否有微信认证与商标认证、公众号注册时间等条件。值得注意的是，开通A级样式还有推广搜一搜的要求，即品牌主在投放广告时或在自有宣传渠道上，要有“微信搜一搜”搜索框露出。线上线下渠道都可以，比如：电梯间广告、户外大屏广告、易拉宝、门店宣传、自有小程序曝光、公众号文章广告、朋友圈广告等等。 支付宝&百度：品牌主页没有特殊展示，入口很“隐蔽”相较于微信官方区，支付宝品牌直达与百度品牌名片的样式则显得尤为“简陋”。展示上，支付宝品牌直达与其他搜索结果并无差别，而百度品牌名片本身即是一个小程序。所以，在入口上，支付宝品牌直达与百度品牌名片都不够突出。对于企业来说，“品牌主页”的作用，就是为了让用户在众多搜索结果中一眼就能看到自家品牌，而“与众不同”的样式，入口也就更“夺目”，这一点，微信官方区是合格的。从品牌曝光来看，支付宝与百度的“品牌主页”在入口上都没有明显优势。如此看来，微信品牌官方区完胜。流量曝光第二环：关键词配置对比完三家“品牌主页”的样式，再来看关键词配置。毕竟，用户输入什么关键词，才能将“品牌主页”搜索出来才是最重要的。微信：级别越高，可配置关键词数量越多刚刚提到，微信品牌官方区有A、B、C三种不同级别。所以，可配置的关键词数量也是不一样的，分别为5个、3个、1个。所以，这对企业来说，可操作空间不大，但仍旧需要将与品牌相关的常见关键词都加上。比如，开通A级官方区的“同程旅游网”，其相关的关键词有同程旅游、同程、同程艺龙等，但晓程序观察（yinghoo-tech）测试后发现，输入“同程艺龙”，并不会出现“同程旅游网”品牌官方区，说明其没有配置关键词“同程艺龙”。同样的问题，也出现在开通B级官方区的“麦当劳”上，搜索英文名称McDonald，就不会出现其品牌官方区。支付宝&百度：“关键词要与品牌名称完全一致”支付宝品牌直达与百度品牌名片的关键词完全不用主动配置，但是，对企业、对用户都极其不友好。因为，只有在用户精确搜索品牌词时，搜索结果中才会出现“品牌主页”。百度品牌名片更甚，据百度官方介绍，用户需要输入“品牌名+品牌名片”（如齐家网品牌名片），或者输入开发者在后台填写的企业全称。对此，晓程序观察也测试了一番，输入“齐家网”后，在搜索结果中，整个第一页都没有看到“齐家网品牌名片”的身影。因此，在“品牌主页”的关键词配置上，微信有一定的运营空间，而百度与支付宝则完全没有。流量曝光第三环：搜索排名对于搜索平台的逻辑来说，决定流量价值的，除了关键词，当然就是搜索结果页排名了。BAT三家“品牌主页”的排名规则，又有什么不一样？微信：“品牌主页”始终占据首位在搜一搜结果页中，微信官方区始终是以首位展示。比如，输入“同程”后，结果页中排在第一位的便是“同程旅游网”品牌官方区，而后才是文章、公众号、小程序、朋友圈等内容。当然前提是，需要针对特定搜索词才能保证官方区首位展示。不同级别的官方区，指定关键词数量也是不一样的。此外，搜索词申请也有一定的要求：须为品牌词汇：针对通用词汇，比如汉堡、保险等，不开放置顶申请；须具有品牌独占性：针对非品牌独占词汇，比如阿拉丁等，不开放置顶申请。支付宝：可通过运营手段来提升搜索排名相比于微信官方区首位展示，支付宝品牌直达的搜索排名则由算法决定。算法维度主要包括：搜索结果中品牌直达的访问和点击用户数、开通品牌直达后搜索带来的增量用户数等，而这些数据都可以利用运营手段来提升。需要注意的是，支付宝品牌直达内包括了小程序、生活号等内容；所以，企业们只需运营品牌直达即可，这样便能同时提升小程序与生活号的排名竞争力。比如，在运营活动中，就可以引导用户“上支付宝搜XXX”，从而改善搜索UV、搜索UV增量数据。百度：广告排在品牌主页前面作为一个搜索引擎平台，百度品牌名片的排名同样根据算法得到，至于逻辑目前还不太清楚。不过，据我们的测试来看，百度品牌名片并不会排在首位，“取而代之”的则是与关键词相关的广告内容。如图，输入“齐家网品牌名片”之后，出现在首位是与齐家网毫无关系的广告内容。综上，微信官方区首位展示，显然是最能帮助企业实现品牌曝光的。而支付宝与百度，还需要开发者在运营规范中自行摸索算法。比如，支付宝品牌直达的搜索UV就是其算法中一个很重要的因素。2在至关重要的拉新与转化上百度输了？对于企业而言，“品牌主页”能带来流量曝光是远远不够的，其更加看重的，仍是拉新与转化。这一点，目前只有微信品牌官方区与支付宝品牌直达能够做到。事实上，BAT三家“品牌主页”看似差别不大，都可以在“品牌主页”内添加小程序等入口，但在拉新与转化上，百度则略逊一筹。原因是微信与支付宝“品牌主页”具备以下两个能力：1.可在品牌主页内直接添加服务与商品在微信与支付宝的“品牌主页”内，开发者能够配置其小程序的服务或商品。品牌在搜索结果页中就能直接触达用户，转化能力更强。用户点击服务或商品后，落地页都是品牌关联的小程序，比如，在NIKE的微信品牌官方区内，点击商品，进入的就是“Nike耐克”小程序的商品详情页。目前，微信品牌官方区最多可在搜索结果页展示4个服务与3个商品；而支付宝品牌直达，仅可添加1-2个小程序服务。2.品牌主页可与功能直达打通在微信与支付宝“品牌主页”中，可与“功能直达”打通，也是其一项重要开放能力。（关于BAT三家功能直达，我们此前已有过测评对比，请点击阅读）在微信搜一搜中，品牌官方区的服务和商品也会出现在相关搜索结果中，拥有更多曝光；同样，用户在支付宝搜索的关键词与某功能关键词匹配时，便会触发功能直达，小程序内的服务便可直接出现在结果页中。相比之下，百度不仅在搜索结果页没有服务入口，在品牌详情页内也不可添加小程序内某个服务，目前只能起到展示作用。综上，无论是“品牌主页”样式，还是流量曝光，微信官方区都要更加完善；而支付宝与百度则处于刚刚起步的阶段，尤其是百度品牌名片，并没有将百度的搜索价值利用至最大化。那么，企业开发者们，BAT三家“品牌名片”，你们会怎么运营？欢迎留言哦~ \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "微信-小程序开发基础知识笔记 ", "author": "Rolan", "time": "2019-11-22 00:41", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    绑定事件的方法：1.bindtab和catchtab，catchtab可以阻止事件冒泡\r\n<view bindtap='onClick'></view>\r\n\r\n<view catchtap='onClick'></view>\r\n2.互斥事件绑定 mut-bind一个 mut-bind 触发后，如果事件冒泡到其他节点上，其他节点上的 mut-bind 绑定函数不会被触发，但 bind 绑定函数和 catch 绑定函数依旧会被触发。在想要规定冒泡区间时可以用到。\r\n<view mut-bind:tap='onClick'></view>\r\n在基础库版本 2.7.1 以上，可以使用 mark 来识别具体触发事件的 target 节点\r\n<view mark:myMark=\"last\" bindtap=\"bindViewTap\">\r\n\r\n<button mark:anotherMark=\"leaf\" bindtap=\"bindButtonTap\">按钮</button>\r\n\r\n</view>\r\n在上述 WXML 中，如果按钮被点击，将触发 bindViewTap 和 bindButtonTap 两个事件，事件携带的 event.mark 将包含 myMark 和 anotherMark 两项。\r\nPage({\r\n\r\nbindViewTap: function(e) {\r\n\r\ne.mark.myMark === \"last\" // true\r\n\r\ne.mark.anotherMark === \"leaf\" // true\r\n\r\n}\r\n\r\n})\r\nmark 和 dataset 很相似，主要区别在于：1.mark可以冒泡，如果存在同名的 mark ，父节点的 mark 会被子节点覆盖。2.在自定义组件中接收事件时， mark 不包含自定义组件外的节点的 mark。3.不同于 dataset ，节点的 mark 不会做连字符和大小写转换。.wxs文件的应用个人理解 .wxs文件就相当于cocos的prefab。执行起来比js性能要快。但是wxs是一门语言，平行于JavaScript。wxs基础语法有频繁用户交互的效果在小程序上表现是比较卡顿的，这时建议使用wxs，为什么？因为小程序分为视图层和逻辑层，比如需要拖动的功能，touchmove事件从视图层抛到逻辑层，逻辑层经过处理，通过this.setData到视图层。1. 一次 touchmove 的响应需要经过 2 次的逻辑层和渲染层的通信以及一次渲染，通信的耗时比较大。2. 此外 setData 渲染也会阻塞其它脚本执行，导致了整个用户交互的动画过程会有延迟。WXS 函数的除了纯逻辑的运算，还可以通过封装好的ComponentDescriptor 实例来访问以及设置组件的 class 和样式，对于交互动画，设置 style 和 class 很方便。代码示例：\r\nvar wxsFunction = function(event, ownerInstance) {\r\n\r\nvar instance = ownerInstance.selectComponent('.classSelector') // 返回组件的实例\r\n\r\ninstance.setStyle({\r\n\r\n\"font-size\": \"14px\" // 支持rpx\r\n\r\n})\r\n\r\ninstance.getDataset()\r\n\r\ninstance.setClass(className)\r\n\r\n// ...\r\n\r\nreturn false // 不往上冒泡，相当于调用了同时调用了stopPropagation和preventDefault\r\n\r\n}\r\n自定义组件上边在分析复杂交互时我们知道，频繁的调用this.setData会使页面卡顿，甚至导致小程序僵死。那么不想写或者说不会写wxs的开发者该怎么办呢？此时可以通过将页面的 setData 改为 自定义组件 中的 setData 来提升性能。原因：自定义组件中的setData不会进行深复制。（深复制会在这个值被组件间传递时才发生）自定义组件的规范1.在组件wxss中不应使用ID选择器、属性选择器和标签名选择器，就只使用class选择器准没错。2.在自定义组件的 js 文件中，需要使用 Component() 来注册组件。3.使用已注册的自定义组件前，首先要在页面的 json 文件中进行引用声明。4.自定义组件和页面所在项目根目录名不能以“wx-”为前缀，否则会报错。5.<slot></slot>相当于react的this.props.children。\r\n<!-- component-tag-name组件 -->\r\n\r\n<view class=\"wrapper\">\r\n\r\n<view>这里是组件的内部节点</view>\r\n\r\n<slot></slot>\r\n\r\n</view>\r\n\r\n<!-- 引用组件的页面模板 -->\r\n\r\n<view>\r\n\r\n<component-tag-name>\r\n\r\n<!-- 这部分内容将被放置在组件 <slot> 的位置上 -->\r\n\r\n<view>这里是插入到组件slot中的内容</view>\r\n\r\n</component-tag-name>\r\n\r\n</view>\r\n6.默认情况下，一个组件的wxml中只能有一个slot。需要使用多slot时，可以在组件js中声明启用。\r\nComponent({\r\n\r\noptions: {\r\n\r\nmultipleSlots: true // 在组件定义时的选项中启用多slot支持\r\n\r\n},\r\n\r\nproperties: { /\\* ... \\*/ },\r\n\r\nmethods: { /\\* ... \\*/ }\r\n\r\n})\r\n此时，可以在这个组件的wxml中使用多个slot，以不同的 name 来区分。\r\n<!-- 组件模板 -->\r\n\r\n<view class=\"wrapper\">\r\n\r\n<slot name=\"before\"></slot>\r\n\r\n<view>这里是组件的内部细节</view>\r\n\r\n<slot name=\"after\"></slot>\r\n\r\n</view>\r\n使用时，用 slot 属性来将节点插入到不同的slot上。\r\n<!-- 引用组件的页面模板 -->\r\n\r\n<view>\r\n\r\n<component-tag-name>\r\n\r\n<!-- 这部分内容将被放置在组件 <slot name=\"before\"> 的位置上 -->\r\n\r\n<view slot=\"before\">这里是插入到组件slot name=\"before\"中的内容</view>\r\n\r\n<!-- 这部分内容将被放置在组件 <slot name=\"after\"> 的位置上 -->\r\n\r\n<view slot=\"after\">这里是插入到组件slot name=\"after\"中的内容</view>\r\n\r\n</component-tag-name>\r\n\r\n</view>\r\n7.设置自定义组件的捕获和冒泡机制需要使用 triggerEvent 方法。\r\n// 组件 my-component.js\r\n\r\nComponent({\r\n\r\nmethods: {\r\n\r\nonTap: function(){\r\n\r\nthis.triggerEvent('customevent', {}, { bubbles: true, composed: true })\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n组件中的behaviors个人理解：多个页面可能会共用一个功能，这个功能抽象后称为组件。多个组件共用一个方法或者多个方法，这类方法的集合称为behaviors。就tm理解成高阶组件就完了。组件间关系relations官方说：有时需要实现这样的组件：\r\n<custom-ul>\r\n\r\n<custom-li> item 1 </custom-li>\r\n\r\n<custom-li> item 2 </custom-li>\r\n\r\n</custom-ul>\r\n说custom-ul 和 custom-li 都是自定义组件，它们有相互间的关系，相互间的通信往往比较复杂。具体怎么个复杂需要单独拎出来一个ralations属性来处理，咱也不知道。使用方法：\r\n// path/to/custom-ul.js\r\n\r\nComponent({\r\n\r\nrelations: {\r\n\r\n'./custom-li': {\r\n\r\ntype: 'child', // 关联的目标节点应为子节点\r\n\r\nlinked: function(target) {\r\n\r\n// 每次有custom-li被插入时执行，target是该节点实例对象，触发在该节点attached生命周期之后\r\n\r\n},\r\n\r\nlinkChanged: function(target) {\r\n\r\n// 每次有custom-li被移动后执行，target是该节点实例对象，触发在该节点moved生命周期之后\r\n\r\n},\r\n\r\nunlinked: function(target) {\r\n\r\n// 每次有custom-li被移除时执行，target是该节点实例对象，触发在该节点detached生命周期之后\r\n\r\n}\r\n\r\n}\r\n\r\n},\r\n\r\n// path/to/custom-li.js\r\n\r\nComponent({\r\n\r\nrelations: {\r\n\r\n'./custom-ul': {\r\n\r\ntype: 'parent', // 关联的目标节点应为父节点\r\n\r\nlinked: function(target) {\r\n\r\n// 每次被插入到custom-ul时执行，target是custom-ul节点实例对象，触发在attached生命周期之后\r\n\r\n},\r\n\r\nlinkChanged: function(target) {\r\n\r\n// 每次被移动后执行，target是custom-ul节点实例对象，触发在moved生命周期之后\r\n\r\n},\r\n\r\nunlinked: function(target) {\r\n\r\n// 每次被移除时执行，target是custom-ul节点实例对象，触发在detached生命周期之后\r\n\r\n}\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n注意：必须在两个组件定义中都加入relations定义，否则不会生效。还有一种情况，如果你两个自定义组件都用了相同的behaviors，你可以使用这个behavior来代替组件路径作为关联的目标节点。\r\n// path/to/custom-form.js\r\n\r\nvar customFormControls = require('./custom-form-controls')\r\n\r\nComponent({\r\n\r\nrelations: {\r\n\r\n'customFormControls': {\r\n\r\ntype: 'descendant', // 关联的目标节点应为子孙节点\r\n\r\ntarget: customFormControls\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n组件中的observers官方定义他叫数据监听器，呵呵。使用方法：\r\nComponent({\r\n\r\nattached: function() {\r\n\r\nthis.setData({\r\n\r\nnumberA: 1,\r\n\r\nnumberB: 2,\r\n\r\n})\r\n\r\n},\r\n\r\nobservers: {\r\n\r\n'numberA, numberB': function(numberA, numberB) {\r\n\r\n// 在 numberA 或者 numberB 被设置时，执行这个函数\r\n\r\nthis.setData({\r\n\r\nsum: numberA + numberB\r\n\r\n})\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n如果需要监听所有子数据字段的变化，可以使用通配符 。\r\nComponent({\r\n\r\nobservers: {\r\n\r\n'some.field.**': function(field) {\r\n\r\n// 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发\r\n\r\n// （除此以外，使用 setData 设置 this.data.some 也会触发）\r\n\r\nfield === this.data.some.field\r\n\r\n},\r\n\r\n},\r\n\r\nattached: function() {\r\n\r\n// 这样会触发上面的 observer\r\n\r\nthis.setData({\r\n\r\n'some.field': { /* ... */ }\r\n\r\n})\r\n\r\n// 这样也会触发上面的 observer\r\n\r\nthis.setData({\r\n\r\n'some.field.xxx': { /* ... */ }\r\n\r\n})\r\n\r\n// 这样还是会触发上面的 observer\r\n\r\nthis.setData({\r\n\r\n'some': { /* ... */ }\r\n\r\n})\r\n\r\n}\r\n\r\n})\r\n特别地，仅使用通配符 可以监听全部 setData 。**纯数据字段就是局部变量，不参与渲染，也不会传递。官方说这样声明后再用能提高性能，要不我才不用。使用方式：\r\nComponent({\r\n\r\noptions: {\r\n\r\npureDataPattern: /^_/ // 指定所有 _ 开头的数据字段为纯数据字段\r\n\r\n},\r\n\r\ndata: {\r\n\r\na: true, // 普通数据字段\r\n\r\n_b: true, // 纯数据字段\r\n\r\n},\r\n\r\nmethods: {\r\n\r\nmyMethod() {\r\n\r\nthis.data._b // 纯数据字段可以在 this.data 中获取\r\n\r\nthis.setData({\r\n\r\nc: true, // 普通数据字段\r\n\r\n_d: true, // 纯数据字段\r\n\r\n})\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n抽象节点又一个新名词，呵呵呵。说白了就是有一个父容器组件A，因为条件不同有可能A中会渲染组件B，也可能渲染组件C。举个例子，当页面需要单选和多选组件的时候,方法1是按条件引用两个封装好的组件（<单选/>，</多选>），方法2是你也可以只引用一个组件<啦啦啦/>，只不过这个<啦啦啦/>组件去帮你按需渲染<单选/>或者<多选/>。需要在父容器组件A的.json文件声明：\r\n{\r\n\r\n\"componentGenerics\": {\r\n\r\n\"selectable\": true\r\n\r\n}\r\n\r\n}\r\n在使用组件时，必须指定父组件具体是渲染哪个子组件：<啦啦啦 generic:selectable=\"单选\" /><啦啦啦 generic:selectable=\"多选\" />在页面的.json文件<啦啦啦/>，<单选/>，<多选/>都要引用。代码\r\n//page下页面的.json文件中\r\n\r\n{\r\n\r\n\"usingComponents\": {\r\n\r\n\"啦啦啦\": \"path/*/*\",\r\n\r\n\"多选\": \"*/checkbox\",\r\n\r\n\"单选\": \"*/radio\"\r\n\r\n}\r\n\r\n}\r\n当然，你也可以在容器组件.json中指定默认用哪个组件：\r\n{\r\n\r\n\"componentGenerics\": {\r\n\r\n\"selectable\": {\r\n\r\n\"default\": \"*/checkbox\"// 多选\r\n\r\n}\r\n\r\n}\r\n\r\n}\r\n计算属性今天真是开眼了，学到了这么多新词汇。。( 计算属性的作用）：是为了解决HTML代码中复杂的js代码（HTML代码中可以嵌套js代码），把复杂的js代码通过计算属性来解决这是计算属性的应用？？？ 听着词这么厉害干这事真是大才小用了。计算属性会使用缓存机制，如果这个数据的值没有改变，则计算属性将不会调用方法这点应该是它实际有价值的地方。实现原理很简单，就是对已有的 setData 进行二次封装，在每次 setData 的时候计算出 computed 里各字段的值，这期间可以增加缓存机制，属性值没有变化的复用。自定义组件拓展在react中想拓展一个组件怎么办，会用高阶组件。小程序中，自然是使用behaviors。\r\n// behavior.js\r\n\r\nmodule.exports = Behavior({\r\n\r\ndefinitionFilter(defFields) {\r\n\r\ndefFields.data.from = 'behavior'\r\n\r\n},\r\n\r\n})\r\n\r\n// component.js\r\n\r\nComponent({\r\n\r\ndata: {\r\n\r\nfrom: 'component'\r\n\r\n},\r\n\r\nbehaviors: [require('behavior.js')],\r\n\r\nready() {\r\n\r\nconsole.log(this.data.from) // 此处会发现输出 behavior 而不是 component\r\n\r\n}\r\n\r\n})\r\nBehavior() 构造器提供了新的定义段 definitionFilter ，用于支持自定义组件扩展。 \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "uniapp登录流程详解uni.login ", "author": "Rolan", "time": "2019-11-25 00:16", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    uni.login(OBJECT)登录H5平台登陆注意事项：微信内嵌浏览器运行H5版时，可通过js sdk实现微信登陆，需要引入一个单独的js，详见普通浏览器上实现微信登陆，并非开放API，需要向微信申请，仅个别开发者有此权限H5平台的其他登陆，比如QQ登陆、微博登陆，uni-app未封装，请在条件编译里按普通H5写法编写。OBJECT 参数说明参数名 类型 必填 说明 平台差异说明provider String 否 登录服务提供商，通过 uni.getProvider 获取，如果不设置则弹出登录列表选择界面scopes String/Array 见平台差异说明 授权类型，默认 auth_base。支持 auth_base（静默授权）/ auth_user（主动授权） / auth_zhima（芝麻信用） 支付宝小程序timeout Number 否 超时时间，单位ms 微信小程序、百度小程序success Function 否 接口调用成功的回调fail Function 否 接口调用失败的回调函数complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行）success 返回参数说明参数名 说明authResult 登录服务商提供的登录信息，服务商不同返回的结果不完全相同errMsg 描述信息uni.login({\r\n  provider: 'weixin',\r\n  success: function (loginRes) {\r\n    console.log(loginRes.authResult);\r\n  }\r\n});uni.checkSession检查登录状态是否过期属性 类型 必填 说明success function 否 接口调用成功的回调函数fail function 否 接口调用失败的回调函数complete function 否 接口调用结束的回调函数（调用成功、失败都会执行）uni.getUserInfo(OBJECT)获取用户信息。UNI-APP 开发微信公众号（H5）JSSDK 的使用方式在 uniapp 中可以使用模块方式引用微信 js-sdk ，微信官网直接下载的使用有问题，可以使用 jweixin-module。安装下载使用方式下载地址： https://unpkg.com/jweixin-mod...使用、var jweixin = require('jweixin-module')  \r\njweixin.ready(function(){  \r\n    // TODO  \r\n});一、小程序:1、使用 button 组件，并将 open-type 指定为 getUserInfo 类型，获取用户基本信息。详情参考文档:https://developers.weixin.qq....2、使用 open-data 展示用户基本信息。详情参考文档:https://developers.weixin.qq....provider String 否 登录服务提供商，通过 uni.getProvider 获取withCredentials Boolean 否 是否带上登录态信息。 微信小程序、头条小程序lang Number 否 指定返回用户信息的语言，默认为 en。更多值请参考下面的说明。 微信小程序timeout Number 否 超时时间，单位 ms。 微信小程序success Function 否 接口调用成功的回调fail Function 否 接口调用失败的回调函数complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行）userInfo 参数说明参数 类型 说明 平台差异说明nickName String 用户昵称openId String 该服务商唯一用户标识 5+AppavatarUrl String 用户头像uni.login({\r\n  provider: 'weixin',\r\n  success: function (loginRes) {\r\n    console.log(loginRes.authResult);\r\n    // 获取用户信息\r\n    uni.getUserInfo({\r\n      provider: 'weixin',\r\n      success: function (infoRes) {\r\n        console.log('用户昵称为：' + infoRes.userInfo.nickName);\r\n      }\r\n    });\r\n  }\r\n});说明：调用 wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。调用 auth.code2Session 接口，换取 用户唯一标识 OpenID 和 会话密钥 session_key。之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。注意：会话密钥 session_key 是对用户数据进行 加密签名 的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。临时登录凭证 code 只能使用一次uni.getProvider(OBJECT)获取服务供应商。仅App平台支持。在App平台，可用的服务商，是打包环境中配置的服务商，与手机端安装了什么app没有关系。云打包在manifest中配置相关模块和SDK信息，离线打包在原生工程中配置。某个服务商配置被打包进去，运行时就能得到相应的服务供应商。关于目前文章内容即涉及前端，PHP知识点，如果有兴趣即可关注，很荣幸，能被您发现，真是慧眼识英！也感谢您的关注，在未来的日子里，希望能够一直默默的支持我，我也会努力写出更多优秀的作品。我们一起成长，从零基础学编程，将 Web前端领域、数据结构与算法、网络原理等通俗易懂的呈现给小伙伴。分享 Web 前端相关的技术文章、工具资源、精选课程、热点资讯。若本号内容有做得不到位的地方（比如：涉及版权或其他问题），请及时联系我们进行整改即可，会在第一时间进行处理。请点赞！因为你们的赞同/鼓励是我写作的最大动力！ \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "微信小程序开发注意指南和优化实践 ", "author": "Rolan", "time": "2019-6-19 00:40", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    前言转眼间已经参与过我厂好几个小程序的开发了，下面本妹子将开发中的那些注意点和各位小伙伴们分享下，妥妥的干货一枚。一、WXML不要换行写，有空格不行微信开发者工具不会对代码进行trim操作，如果代码中换行，页面也直接换行。wx:if vs hidden一般来说，wx:if 有更高的切换消耗而 hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 hidden 更好，如果在运行时条件不大可能改变则 wx:if 较好。图片处理1.大图片也会造成页面切换的卡顿有一部分小程序会在页面中引用大图片，在页面后退切换中会出现掉帧卡顿的情况。 2.图片占容量 代码包限制是2MB，图片占用空间较大，建议都上传到 CDN 上，代码里直接引用链接。 3.大图片小点击位 小程序主要在手机端运行，手机屏幕大小有限，所以尽量点击位大点。 4.图片截取 存在图片没有按原图宽高比例显示，可以设置 image 组件的 mode 属性，来保持原图宽高比。 5.CSSSprites 所有零星图片都包含到一张大图中，减少请求数WXS 模块每个 wxs 模块均有一个内置的 module 对象。 直接在wxml中引入，可以将写需要转化数据的写进去，防止给setData加负担使用了过大的 WXML 节点数目一个太大的WXML节点树会增加内存的使用，样式重排时间也会更长，建议一个页面使用少于 1000 个WXML的节点，节点树深度少于 30 层，子节点数不大于 60 个二、WXSSCss伪类看不到在微信开发者工具中， Styles 不会显示 Css 伪类，喜欢写::before或:first-child的小伙伴们请注意了，你的伪类在控制台是看不到的,所以本妹子不建议在小程序里用 Css 伪类，以防找不到问题点不好修复bug。小程序 button 自带给 after 伪类添加了边框，通过开发者工具是看不到 after ,我们需要自行去掉边框。button::after {\r\n  border: none;\r\n}hover 伪类则可以用小程序自带的属性 hover-class 代替。部分CSS3属性不能用如transform:rotate(180deg)，不能用。自定义颜色限制不是所以颜色配置都能随心所欲，比如导航栏标题颜色，仅支持 black / white；下拉 loading 的样式，仅支持 dark / light。所以出视觉图关注下。滚动区域没有开启惯性滚动当加了overflow: scroll时， IOS 下需要额外设置： -webkit-overflow-scrolling: touch，来开启惯性滚动。三、JSJavaScript 支持情况如果需要支持到 IOS8 话，建议下面 js 方法都不使用。分享事件不支持异步如果你想自定义分享图片，则在生命周期onShareAppMessage中编写如下所示：Page({\r\n  onShareAppMessage: function (res) {\r\n    return {\r\n      title: '自定义转发标题',\r\n      imageUrl: 'https://raoenhui.github.io/images/logo.png'\r\n    }\r\n  }\r\n})但是 onShareAppMessage 不能支持异步，如果你想从接口里获取分享图片URL，必须在 onLoad 提前读取并放入Data中小程序有并发限制wx.request、wx.uploadFile、wx.downloadFile 的最大并发限制是 10 个。所有为了保险起见，需要写个请求队列，如果并发量大于10，则等待请求。采用公共方法和组件编写公共方法和组件，可以避免重复造轮子。 1.公共埋点方法 2.各种处理js的方法（转https，throttle，formatTime等） 3.公共组件（iphonex兼容组件，倒计时组件等）catch绑定事件比如 catchtouchmove 弹框禁止滑动 bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。循环中添加key对于经常要更新的列表需要加上 key 值，key值相当于索引，但是 key 值不要用 index ,因为 index 在增加删除的时候可能不变产生混乱，推荐用唯一标示 id ，对数据改变之后的diff更新比较有很大的性能提升。 PS：如果是单纯只显示的列表，不需要操作更新，那不需要加 key 。巧用nextTick小程序和vue写法比较相似，也有 nextTick ,在当前同步流程结束后，下一个时间片执行 。 比如有些取视图层的数据，可以等页面上流程结束后再取比较准确wx.nextTick(() => {\r\n      query.select('.percent-line-toast').boundingClientRect() \r\n    })处理后台运行的jssetTimeout一定伴随着clearTimeout setInterval一定伴随着clearInterval 这些我们经常会滚动算高度，倒计时，动画中用到。当我跳到了另外一个页面还在运行，小心后台页面的jswx.hide的坑两个都是基于同一个原生toast实例实现的，wx.showLoading()与wx.showToast(), 同时只能显示一个， wx.hideLoading()也会隐藏Toast ; wx.hideToast()也会隐藏Loading， 失败的提示toast会一闪而过的问题，可能时因为调用了wx.hideLoading()。http需变httpsHTTP是明文传输有篡改内容的风险，而且有些安卓机会不兼容。所以我们需要使用https。 所以开需求评审的时候，要注意后端要写成https，如果是运营配的数据，后端最好有个转https方法，输入了url自动转成https链接。在微信开发者工具中，可勾选”不校验合法域名、web-view（业务域名）、TLS 版本以及 HTTPS 证书”规则即可用http，但是在实体里并没有这个选项，所以建议开发时就用https路径。埋点的坑埋点用公共方法，页面曝光 pv 埋点放入 onshow 生命周期中更加准确。预加载1.数据预加载 上个页面就将接口请求好，存到对象中，下个页面直接从对象中拿，有利有弊，从业务角度出发看是否需要预加载数据 storage也可以存储数据，同一个微信用户，同一个小程序 storage 上限为 10MB。分包预加载preloadRule preloadRule预下载分包行为在进入某个页面时触发，享有共同的预下载大小限额 2M。\"preloadRule\": {\r\n \"sub1/index\": {\r\n   \"packages\": [\"important\"]\r\n }\r\n}3.图片预加载 对视觉效果要求越来越高，多张图片如果想动画显示流畅，可以先加载图片，直接用request先请求图片下来。setData注意点1. 频繁的去 setData存在将未绑定在 WXML 的变量都不需要传入 setData。 2. 每次 setData 都传递大量新数据，可局部更新this.setData({\r\n    list[index] = newList[index]\r\n})3. 后台态页面进行 setData当页面进入后台态（用户不可见），不应该继续去进行 setData ，后台态页面的渲染用户是无法感受的，另外后台态页面去 setData 也会抢占前台页面的执行。也就是上文提到的不要忘了 clearTimeout 、 clearInterval 。四、其他使用分包由于小程序包大小有限制，整个小程序所有分包(包括独立分包和普通分包)大小不超过 8M，单个分包/主包大小不能超过 2M，建议把首屏不需要展示的都放入分包中，分包就像H5打出的chunk包一样，可以按需加载。及时清理没有使用到的代码和资源在日常开发的时候，我们可能引入了一些新的库文件，而过了一段时间后，由于各种原因又不再使用这个库了，我们常常会只是去掉了代码里的引用，而忘记删掉这类库文件了。目前小程序打包是会将工程下所有文件都打入代码包内，也就是说，这些没有被实际使用到的库文件和资源也会被打入到代码包里，从而影响到整体代码包的大小。sitemap 配置小程序根目录下的 sitemap.json 文件用于配置小程序及其页面是否允许被微信索引，文件内容为一个 JSON 对象，如果没有 sitemap.json ，则默认为所有页面都允许被索引.单元测试miniprogram-simulate模拟 touch 事件、自定义事件触发 选取子节点 更新自定义组件数据 触发生命周期检测工具开发者工具自带检测评分页面，可以分析页面存在的问题。wxss 覆盖率较低，有些动画样式比如 @keyframes 是检测不到的。以及可以通过性能面板查看页面性能。小伙伴们有其他建议欢迎留言评论^ ^ \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "5个套路看懂微信小程序开发 ", "author": "Rolan", "time": "2019-6-21 00:17", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    你或许听说过，快速入门就是要学最小必要知识。而我最近在看微信小程序的官方教程时发现，这个教程虽然简单，但对于微信小程序开发来说，80%的套路都能从这里学习到，你的小程序从0到1可以从这里实现突破。在开始之前，先做100字的铺垫。一个页面 = 4个文件小程序的每个页面都是由4个文件组成的 ，前两个最重要，是我们的重头戏。先给这几个文件一个简短的解释：js 文件——数据来源；wxml 文件——页面的骨架；wxss 文件——页面的装饰效果；json 文件——可选，配置页面上的零件。另外，本文的目标读者是真心想要尝试小程序的无经验开发者，英语水平要求中学及格水平以上。另外，为了你可以动手跟着做，请下载微信开发工具并注册微信小程序。部分语言过于通俗是为了更好的理解。绑定数据现在就开始我们的第一个套路。小程序简易教程 -> 编写代码 -> 创建页面 -> 第二个代码块依照小程序的定义，小程序中的每个页面都包含一个js文件。在一个 js 文件中，你需要列出这个页面上需要的数据（上图红框中的内容）。也就是说，data下面规定的数据（请努力去上图中找到 data），就是页面上需要用到的数据。这就叫做数据绑定。「数据绑定」对你来说可能是个新词汇。这里先不急着理解，我们的目标是会用，会用了就能理解一大半了。怎么应用「数据绑定」呢？只需要两步：1，声明；2，使用。声明的格式是这样的（类似上图中的内容）：Page({data: {greeting: 'Hello World'}//...})在微信开发工具中是这样的：注意看红框中的内容，和上面的代码块是一样的注意看 data 那个部分，我声明了名字为greeting的数据。（所谓数据，学名应该叫变量，但在我们的教程里可以近似理解。）第二步是使用。使用的意思是，我们到页面上把这个数据显示出来。方法是这样的：{{greeting}}注意看{{ }}之间的部分，我们只需要把刚刚定义好的数据名称写在两个大括号里就行了。顺带一提，这种使用数据的方法，叫做八字胡方法（英文Mustache），因为加上的两个大括号可以想象成嘴上的胡子。或许记住了胡子，你就记住了这种使用方法。这就完成了我们的第一个套路——数据绑定。简单吧！但是这里有一个疑问，我们在哪里使用绑定好的数据呢？也就是问，在哪里使用{{greeting}}这句程序呢？答案是我们的页面上，也就是 wxml 这个文件中。这就是我们的下一个套路——显示数据。显示数据上一个套路的讲解中，我们出现了这样一句程序{{greeting}}。这是在使用数据。但这行代码的完整版其实是这样的：<text class=\"your-class\">{{greeting}}</text>在微信开发工具中的样子是这样的：还是看红框内的内容，也请注意这是在 wxml 文件中我们对{{greeting}}这一部分已经熟悉，但对于它前面和后面的代码还不熟悉。所以我们现在进行讲解。显示数据时，我们其实希望显示出来的内容是很好看的。但如果你只写成{{greeting}}，显示出来的效果并不好：最左边红框中的文字一点装饰效果都没有为了让显示数据有更好看的效果，我们需要对{{greeting}}进行装饰。怎么装饰数据呢。我们要用2个东西：标签样式表什么是标签，我们从例子中来理解：{{greeting}}两边的<text class=\"your-class\">和</text>就是标签，而且分别叫开始标签和结束标签。（你能发现开始标签和结束标签的区别么？）开始标签可以定义一些属性，以便调整显示的结果。这就像是你画一幅画可以选择用毛笔，来画出国画的效果。在上面的例子中，class=\"your-class\"就是<text>这个标签的一个属性，<text>标签会表现出class=\"your-class\"的规定的样子。那么class=\"your-class\"这个属性的完整意思是什么呢？他的意思是<text>的 class 对应样式表中的your-class。对，你可以把等号理解为对应。而后面的\"your-class\"就是我们在样式表中规定好的一种装饰效果。这里出现了我们的第2个工具：样式表。样式表是写在 wxss 文件中的，我们来看看怎么写：.your-class {display: flex;flex-direction: column;align-items: center;color: blue;}在开发者工具中的样子是这样的：你通过理解代码中英文的字面意思就可以了解到，我把字的 color 定义为蓝色，把位置定义为 center。最重要的，是这个样式的名字，叫做.your-class，而<text>标签中的 class 属性，正好指向这个样式，所以<text>中的数据会变成中间位置的蓝色字。（在.your-class的最前面有一个点，那是对应<text>中 class 属性的特有标记，还有类似的标记[1]，可以在以后更多的实践中去理解)到这里，我们的前两个套路就已经简单的介绍完了。总结一下：绑定数据：在 js 文件中的 Page 模块下面定义 data 的名字，并用八字胡方法({{ }})来使用数据。显示数据：在 wxml 中给数据加上标签（比如 text 标签），并且给标签加上属性（比如 class 属性）。class 对应的样式在 wxss 文件中写好。不过，我们这里好像缺了什么。我好像没教大家怎么写最后一步的 wxss。微信文档说，wxss 和 css 大体上都是一样的[2]。大家可以去找找css的书，或者期待我后续的实践教程，带你一步一步写一个能上线的小程序。现在，如果你把这两个套路循环用起来，已经能解决很多问题了。想要多显示一个数据，就先在 js文件中绑定这个数据，然后去 wxml 文件中装饰数据。下面是绑定两个数据的示例代码：Page({data: {greeting: 'Hello World',farewell: 'Goodbye!'}//其他内容})而对应显示这两个数据的示例代码是这样的：<!--index.wxml--><text class=\"your-class\">{{greeting}}</text><view class=\"your-class\">{{farewell}}</view>在开发者工具中显示的样子是这样的：我在写教程的过程中升级了一次开发者工具，所以界面有变化大家可以看到，我在最右侧的红箭头处加入了一行新代码， 然后显示出了新数据。但是，这次不一样的是，我用了一个叫做<view>的标签，而不是之前的<text>标签。其实 wxml 文件中可以使用很多种标签来显示数据，有负责显示图片的，有可以负责滚动效果的的，他们都被写在微信文档中，你在实践的过程中可以查看。比如，我使用了一个叫做<icon>的标签，然后显示出了一个圆形的图标：有了「绑定数据」和「显示数据」这两个套路，我们已经能够写出一个简单的页面了。能够做到展示，但没有交互，所以我们进入第三个套路：绑定交互。绑定交互绑定交互这个名字听起来有没有和之前的「绑定数据」很像？他们的操作方法也很相似。绑定交互分为两步：声明：在 js 文件中声明交互的名称。使用：在 wxml 文件中使用这个交互。先来看「声明」。怎么声明一个交互呢？（或者用微信文档的说法，怎么来声明一个事件呢？）请在 js 文件中写下这样几行代码，就在我们之前绑定数据的 data 模块下面：changeWord: function() {this.setData({farewell: 'Never Say Goodbye!'})}在开发者工具中的样子是：这样，我们就声明了一个叫做changeWord的交互。这个交互的具体内容是，改变 farewell 这个数据的内容。原来是Goodbye!，现在我们要改成Never Say Goodbye!。而这个声明中function，this，setDate都是什么意思，我们在后面实践中再讲，大家关注的重点是这个声明中最前面的部分，也就是这个交互的名字：changeWord。我们已经声明完了这个交互，现在就该进入第2步——使用交互。请在 wxml 中插入这样的代码片段：<button bindtap=\"changeWord\" type='primary' class=\"your-button\" size='default'>改变文字</button>在开发者工具中的的样子是这样的：这里的重点是bindtap=\"changeWord\"，大家可以看到我们刚刚声明的交互changeWord出现了，那前面的bingtap=是什么呢？他的意思是：把点击事件的交互对应到changeWord。当你点一下图中的那个绿色按钮，我们的页面就会把Goodbye!换为 Never Say Goodbye!除了利用标签的bindtap属性来绑定交互，还可以用bindlongtap（绑定长按事件），bindtouchmove（绑定触摸后移动事件）等等，他们都有各自的效果。具体内容都被写在事件相关的文档中，你可以亲自试一下。你会发现他们的开头都是 bind，就好像单词的前缀一样，加上tap，longtap等后缀，就能帮你绑定一个交互。（绑定事件的前缀还有另外一种，叫catch，比如catchtap，catchtouchmove等等，你可以结合文档，试验一下他们的效果）[3]到这里，我们已经能够简单的绑定交互了。但绑定交互的核心目的是要改变页面上的显示，从而给用户一个反馈。下面就让我们来看看第4个套路：修改显示。执行交互就像绑定数据之后，要去显示数据。我们绑定交互之后，也要让交互被执行，这样才有意义。而交互的执行内容，就写在被声明的交互的下面：changeWord: function() {// 这里写交互的实际内容}我们这里介绍两种交互内容的写法，足够解决很多问题了：修改页面数据弹窗第一种，修改页面数据。我们在上一个套路的实例代码中已经见过：changeWord: function() {this.setData({farewell: 'Never Say Goodbye!'})}这几行代码中间的部分，就是要执行的交互内容：this.setData({farewell: 'Never Say Goodbye!'})即使你不懂得javaScript编程语言，也完全可以从英语的字面意思去理解这几行代码。这3行代码是在说，我这个页面(this)要修改数据(setData)中的farewell为 Never Say Goodbye!。如果你想修改其他数据，比如greeting，你可以如法炮制：changeAnotherWord: function() {this.setData({greeting: 'Hello, again!'})}你会发现这里面有很多结构是固定的。变化的部分只有交互的名称（变成了changeAnotherWord）和要修改的数据（变成了greeting: 'Hello, again!'）。如果你也想修改页面上的数据，请如法炮制。我们要介绍的第二种交互方法是弹窗，而且是微信内建的弹窗。首先，还是要做一下绑定交互这个套路：1，在 js 文件中声明一个交互；2，在 wxml 中使用这个交互。声明交互的代码如下（在 js 文件中），我们用showConfirmation作为名称： showConfirmation: function() {\r\n var that = this\r\n wx.showModal({\r\n title: '提示',\r\n content: '你确定要更改文字吗？',\r\n showCancel: true,\r\n cancelText: '取消',\r\n confirmText: '确定',\r\n success: function (response) { \r\n that.changeWord()\r\n }\r\n })\r\n }\r\n在微信开发者工具中是这样的：先不要在乎这里面陌生的代码，我们继续看使用交互的部分：<button bindtap=\"showConfirmation\" type='primary' class=\"your-button\" size='default'>改变文字</button>我把上一个套路中出现的 button 改写成了绑定到这个showConfirmation，在微信开发者工具中的样子是这样的：写完之后，我再去点「改变文字」的按钮，就会出现对话框：箭头连接的两部分是一样的，你发现了吗你会发现，所有的不一样，都只是在 js 文件中showConfirmation的下面，其他的部分都符合我们以前的套路。那我们就看看那段陌生的代码： var that = this\r\n wx.showModal({\r\n title: '提示',\r\n content: '你确定要更改文字吗？',\r\n showCancel: true,\r\n cancelText: '取消',\r\n confirmText: '确定',\r\n success: function (response) { \r\n that.changeWord()\r\n }\r\n })\r\n我们从wx.showModal看起，这是一个微信内建的代码表达方式，从英文的字面就能理解他是什么意思：请微信（wx）显示一下对话框（showModal）。那怎么用这个工具呢，微信的文档里面已经写好了：我们只需要像填空一样，把制作对话框需要的 title, content, showCancel 等需要填充的地方填好就可以了。这样，微信会帮助我们制作出一个对话框。但在这段代码中，有一个比较难解释的地方，就是var that = this和that.changeWord()。你能猜到他们是联动的，因为他们都有一个that。具体的意思是：把这个页面存储在那个地方（var that = this），让那个地方的数据中的文字改变（that.changeWord()）。为了避免混乱，我们暂时解释到这里。而且这两行也不影响我们制作一个对话框。因为制作对话框只需要做一件事[4]：使用wx.showModal跳转到这里，我们已经能在一个页面上使用4个套路了：绑定数据，显示数据，绑定交互，修改数据。如果你的小程序比较复杂，那么，是时候跳转到下一个页面来开辟一片新战场。要跳转到下一个页面，我们只需要最后一个套路：跳转。跳转本质上也是一种交互，我们完全可以用上面提到的「绑定交互」和「执行交互」来实现。再重复一遍这两步：1，在 js 文件中声明一个交互；2，在 wxml 中使用这个交互。我们先在 js 文件中声明一个名为navigateToLogs的交互：navigateToLogs: function() {wx.navigateTo({url: '/pages/logs/logs'})}在开发者工具中的样子是这样的：这里面有我们不太熟悉的代码，比如wx.navigateTo，根据上一个套路的经验，你已经能够大致猜到他的意思了，对么？不过我们还是把下一步走完再说。在 wxml 中使用这个交互：<button bindtap=\"navigateToLogs\" type='default' class=\"your-button\" size='default'>跳转</button>在开发者工具中的样子是这样的：好了，现在，如果我们点一下「跳转」按钮，他就会跳到下一页。已经看完了效果，我们回来看那段不熟悉的代码：wx.navigateTo({url: '/pages/logs/logs'})这一次，我们依然可以从字面理解：请微信（wx）导航到（navigateTo）logs 路径下的页面（url: '/pages/logs/logs'）。其中 url 这个数据是微信要求的，在文档中可以找到他的说明，我们依然是照着文档来填空就可以了[5]。这里面有一点需要说明，新页面的地址叫做'/pages/logs/logs'，他是从哪里来的呢？大家看下图红框中的文件结构，会发现 logs 这个页面的地址就是 pages 文件夹下面的 logs 文件夹下面的 logs 文件（有4个文件，但都叫 logs），用标准的格式表示，就成了我们刚刚提到的/pages/logs/logs。更进一步，按照微信的规定，我们还需要把他写在一个叫做app.json的配置文件中，这样微信才允许我们跳转到那个路径。总结一下好了，到这里，我们把5个套路都学完了。如果你能把他们组合起来，不断使用，你就能制作一个用很多功能的小程序：绑定数据——在 js 文件中声明数据名称显示数据——在 wxml 中写出数据显示的位置，并在 wxss 中写出装饰效果绑定交互——在 js 文件中声明交互的名称执行交互——在 js 文件中支出要修改的数据或者显示弹窗跳转——跳转到下一页，开辟新的战场番外篇——调取微信数据微信小程序其实还有一个隐含套路，叫做调用微信提供的接口。用微信官方的话讲，就是使用微信的能力。如果没有这些能力，微信小程序只能叫小程序，而不能叫「微信」小程序。其实，我们已经在上面见过一些微信小程序的能力了，比如显示弹窗的wx.showModal，比如跳转下一页的wx.navigateTo你已经发现，他们的特点都是wx.开头。更多的能力还有，还有获取用户头像，打开扫一扫这样的能力。他们怎么用呢？其实都是查文档，看看这个方法需要你提供哪些数据，提供给他就好了。用两个字总结就是：填空。最后的最后，轻轻说一句，对于刚刚入门的开发者，最大的坑可能是——忘记保存。因为我曾经也是个新手，在很多领域依然是新手，甚至还没有入门。希望这份教程能帮到你。共勉。这种标记叫做选择器，可以在这个小程序 wxss 文档的选择器那一节找到而且是个简版的css，不会用到复杂一点的级联样式另外，还有两类特殊的交互，为了避免大家混乱，我没有讲，但在我们后续的教程中会用到，感兴趣的朋友可以先了解一下：一类是某些标签特有的绑定方法，比如<checkbox-group>便签有一个特有属性 bindchange，可以用来绑定交互。另一类是用户关闭和打开页面时绑定的交互，比如onLoad，这类交互都是以 on 开头的，代表这个页面的事件，直接在 js 文件中声明，不用再 wxml 中绑定到标签。微信还有2个可用弹窗类交互，大家可以对照文档进行实验。微信出了提供wx.navigateTo这个跳转方法，还提供了其他4个导航相关的方法，你可以在实践中体会他们的区别。另外，微信还提供了<navigator>标签来实现跳转，跟wx.navigateTo等方法实现同样效果，为避免混乱，这里只留下文档地址，不详细举例。 \r\n\r\n\r\n\r\n                鲜花                (1)\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "微信小程序开发之页面分享 onShareAppMessage 分享参数用处 ", "author": "Rolan", "time": "2019-8-19 00:08", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    今天下午突然听到群里有人说微信小程序工具更新了,文档也更新了不少内容.顾不上吃冬至的饺子.我就冲进来了.先说分享功能,目前真机尚不能调试.开发工具上可以看看效果.后续还会更新.Page()中加上如下代码后在右上角就会出现三个小白点title:分享的标题.desc:分享一段描述.path:这个参数有点意思.以前在微信中的分享一般都是url.这里是当前页面这里应该是pages/index?id=123这里的id目前还不知道是什么.也就是说以后你可以在微信中像分享一个网页一样分享一个页面了.onShareAppMessage: function () {\r\n    return {\r\n      title: '垃圾分类黑板报',\r\n      desc: '垃圾分类就选垃圾分类黑板报!',\r\n      path: '/page/user?id=123'\r\n    }\r\n  }分享参数用处:我这里没有用到路径后的参数,说个场景:参数是用户昵称,A分享了XXX小程序到微信群里,B点开小程序,弹个toast,”来自A的分享”. \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "微信小程序开发中各种跳转方式的区别 ", "author": "Rolan", "time": "2019-10-21 00:48", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    wx.navigateTo、wx.redirectTo、wx.reLaunch、wx.switchTab和wx.navigateBack有什么区别呢？wx.navigateTo：用于保留当前页面、跳转到应用内的某个页面，使用 wx.navigateBack可以返回到原页面。对于页面不是特别多的小程序，通常推荐使用 wx.navigateTo进行跳转， 以便返回原页面，以提高加载速度。当页面特别多时，则不推荐使用。wx.redirectTo：当页面过多时，被保留页面会挤占微信分配给小程序的内存，或是达到微信所限制的 5 层页面栈。这时应该考虑选择 wx.redirectTo。wx.redirectTo()用于关闭当前页面，跳转到应用内的某个页面。这样的跳转，可以避免跳转前页面占据运行内存，但返回时页面需要重新加载，增加了返回页面的显示时间。wx.reLaunch：wx.reLaunch()与 wx.redirectTo()的用途基本相同， 只是 wx.reLaunch()先关闭了内存中所有保留的页面，再跳转到目标页面。wx.switchTab：对于跳转到 tab bar 的页面，最好选择 wx.switchTab()，它会先关闭所有非 tab bar 的页面。其次，也可以选择 wx.reLaunch()，它也能实现从非 tab bar 跳转到 tab bar，或在 tab bar 间跳转，效果等同 wx.switchTab()。使用其他跳转 API 来跳转到 tab bar，则会跳转失败。wx.navigateBack：用于关闭当前页面，并返回上一页面或多级页面。开发者可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层。这个 API 需要填写的参数只有 delta，表示要返回的页面数。若 delta 的取值大于现有可返回页面数时，则返回到用户进入小程序的第一个页面。当不填写 delta 的值时，就默认其为 1（注意，默认并非取 0），即返回上一页面。本文来自木庄网络博客> wx.navigateTo、wx.redirectTo、wx.reLaunch、wx.switchTab和wx.navigateBack的区别 \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "微信小程序开发者自助解绑小程序 ", "author": "Rolan", "time": "2019-11-14 00:52", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    最近在帮朋友开发小程序时，朋友突然告诉我，不能绑定开发者了。但是就比较纳闷，问了下，才知道，一个微信号只能绑定为50个小程序的开发者。当时就比较懵了，之前我帮过好多人开发过小程序，这些小程序都绑定过我为开发者，可是具体是那些人，真的有点忘记了。就去官方文档搜，还真给搜到了。官方给出的解决办法如下由于忘记都有谁绑定过我为开发者了，所以只能有第二种方式了。 这不看不知道，一看吓一跳啊。我居然被好多根本就没接触过的小程序绑定为开发者了。因为小程序绑定开者太容易了，知道你的微信号，就可以绑定你为开发者。至于这些人为啥要把我添加为开发者呢，想来想去也就这个原因了。一个极速审核奖励。。。。。。大刀阔斧的解绑开发者权限1，搜索微信公众号：公众平台安全助手 ，关注公众号，必须要关注公众号。这个我就不多说了2，进入公众号对话的主界面，左下角找到 <绑定查询> 可以根据手机号、身份证号以及微信号的方式查询，这里要用根据 微信号绑定账号 的方式查询。3，点击进入后，会看到：公众号、小程序、开放平台。因为我们的目的是微信开发者/体验者自主发起解绑小程序账号，所以选择的是小程序，可以看到你目前作为管理员和作为项目成员分别下面有那些小程序账号，在这个页面可以看到每个小程序的头像、名称4，以这个大米色选机为例，点击会弹出上图的解绑按钮，然后点击解绑5，解绑以后会有个以下通知这样就解绑成功了，后面自己慢慢的把自己用不到的，或者自己根本不知道的都给解绑了，后面就剩下这几个自己常用的了。这样以后又可以愉快的帮别人改小程序的代码了。是不是清爽很多了，今天就到这里了。 \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "微信小程序开发技巧 ", "author": "Rolan", "time": "2019-11-18 00:43", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    \r\n开发小程序这么久了，整理了一些技巧清单，分享出来。\r\n1、backgroundColor 配置无效\r\n页面配置中 backgroundColor 可以设置窗口颜色：\r\n{\r\n  \"backgroundColor\": \"#f2f2f2\"\r\n}\r\n复制代码这么设置完之后发现一点效果都没有，仔细研究一番，原来窗口颜色指的是最底层。（真想说句：卧槽~）\r\n\r\n解决这个问题很简单，使用 page 选择器即可：\r\npage {\r\n  background: #f2f2f2;\r\n}\r\n复制代码page 是页面的根节点，也就是h5里的 html，所以可以用来设置一些样式。\r\n2、改变自定义组件根节点样式\r\nheader组件代码如下：\r\n<view class=\"header\">\r\n  header\r\n</view>\r\n复制代码可以看到渲染出来后发现多出 header 节点。\r\n\r\n在大部分开发中跟组件节点并没有什么用， 但是 某些情况下是会影响样式的， 比如说弹性布局，这里不贴demo了，反之此技巧必定用到，回头瞧瞧就行。\r\n我们可以在自定义组件样式文件使用 :host 选择器修改跟组件节点：\r\n:host {\r\n  padding: 50px;\r\n}\r\n复制代码可以对比上图盒子模型\r\n\r\n3、block标签是什么\r\nblock 标签其实就类似于 react 中的 Fragment, Vue中的 template。\r\n如果没接触过 react/vue 没关系，看下面例子：\r\n<block>\r\n  <view>say</view>\r\n  <view>hello</view>\r\n</block>\r\n复制代码渲染后结果, block 节点消失\r\n<view>say</view>\r\n<view>hello</view>\r\n复制代码如果没有block节点，需要这么做:\r\n<!-- 多渲染了跟节点标签 -->\r\n<view>\r\n  <view>say</view>\r\n  <view>hello</view>\r\n</view>\r\n复制代码比较常用的用来配合 wx:if\r\n<block wx:if=\"{{ show }}\">\r\n  <view wx:for=\"{{ arr }}\" wx:key=\"index\">{{ item }}</view>\r\n</block>\r\n复制代码4、如何设置背景图片\r\n搞个背景图片都费劲 [发火]\r\n\r\n平常在h5中设置背景图片直接引入地址就行\r\nbackground: url(\"/example.png\");\r\n复制代码但是在小程序中竟然不可以。。。\r\n为啥？？？\r\n小程序： 你只能乖乖引入网络图片\r\nxx: mmp, 设置个图片都搞那么多花样？ 我觉得...\r\n小程序：我不要你觉得， 我要我觉得。\r\n复制代码xx了。 只能走后门了。\r\n1、可以将图片转成 base64 即可：\r\nbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyBjbGFzcz0ibGRzLXNwaW5uZXIiIHdpZHRoPSIxMDlweCIgIGhlaWdodD0iMTA5cHgiICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQiIHN0eWxlPSJiYWNrZ3JvdW5kOiBub25lOyI+PGcgdHJhbnNmb3JtPSJyb3RhdGUoMCA1MCA1MCkiPgogIDxyZWN0IHg9IjQ3IiB5PSIyNCIgcng9IjkuNCIgcnk9IjQuOCIgd2lkdGg9IjYiIGhlaWdodD0iMTIiIGZpbGw9IiMwMDAiPgogICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0ib3BhY2l0eSIgdmFsdWVzPSIxOzAiIHRpbWVzPSIwOzEiIGR1cj0iMXMiIGJlZ2luPSItMC45MTY2NjY2NjY2NjY2NjY2cyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZT4KICA8L3JlY3Q+CjwvZz48ZyB0cmFuc2Zvcm09InJvdGF0ZSgzMCA1MCA1MCkiPgogIDxyZWN0IHg9IjQ3IiB5PSIyNCIgcng9IjkuNCIgcnk9IjQuOCIgd2lkdGg9IjYiIGhlaWdodD0iMTIiIGZpbGw9IiMwMDAiPgogICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0ib3BhY2l0eSIgdmFsdWVzPSIxOzAiIHRpbWVzPSIwOzEiIGR1cj0iMXMiIGJlZ2luPSItMC44MzMzMzMzMzMzMzMzMzM0cyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZT4KICA8L3JlY3Q+CjwvZz48ZyB0cmFuc2Zvcm09InJvdGF0ZSg2MCA1MCA1MCkiPgogIDxyZWN0IHg9IjQ3IiB5PSIyNCIgcng9IjkuNCIgcnk9IjQuOCIgd2lkdGg9IjYiIGhlaWdodD0iMTIiIGZpbGw9IiMwMDAiPgogICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0ib3BhY2l0eSIgdmFsdWVzPSIxOzAiIHRpbWVzPSIwOzEiIGR1cj0iMXMiIGJlZ2luPSItMC43NXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIj48L2FuaW1hdGU+CiAgPC9yZWN0Pgo8L2c+PGcgdHJhbnNmb3JtPSJyb3RhdGUoOTAgNTAgNTApIj4KICA8cmVjdCB4PSI0NyIgeT0iMjQiIHJ4PSI5LjQiIHJ5PSI0LjgiIHdpZHRoPSI2IiBoZWlnaHQ9IjEyIiBmaWxsPSIjMDAwIj4KICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9Im9wYWNpdHkiIHZhbHVlcz0iMTswIiB0aW1lcz0iMDsxIiBkdXI9IjFzIiBiZWdpbj0iLTAuNjY2NjY2NjY2NjY2NjY2NnMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIj48L2FuaW1hdGU+CiAgPC9yZWN0Pgo8L2c+PGcgdHJhbnNmb3JtPSJyb3RhdGUoMTIwIDUwIDUwKSI+CiAgPHJlY3QgeD0iNDciIHk9IjI0IiByeD0iOS40IiByeT0iNC44IiB3aWR0aD0iNiIgaGVpZ2h0PSIxMiIgZmlsbD0iIzAwMCI+CiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJvcGFjaXR5IiB2YWx1ZXM9IjE7MCIgdGltZXM9IjA7MSIgZHVyPSIxcyIgYmVnaW49Ii0wLjU4MzMzMzMzMzMzMzMzMzRzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSI+PC9hbmltYXRlPgogIDwvcmVjdD4KPC9nPjxnIHRyYW5zZm9ybT0icm90YXRlKDE1MCA1MCA1MCkiPgogIDxyZWN0IHg9IjQ3IiB5PSIyNCIgcng9IjkuNCIgcnk9IjQuOCIgd2lkdGg9IjYiIGhlaWdodD0iMTIiIGZpbGw9IiMwMDAiPgogICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0ib3BhY2l0eSIgdmFsdWVzPSIxOzAiIHRpbWVzPSIwOzEiIGR1cj0iMXMiIGJlZ2luPSItMC41cyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZT4KICA8L3JlY3Q+CjwvZz48ZyB0cmFuc2Zvcm09InJvdGF0ZSgxODAgNTAgNTApIj4KICA8cmVjdCB4PSI0NyIgeT0iMjQiIHJ4PSI5LjQiIHJ5PSI0LjgiIHdpZHRoPSI2IiBoZWlnaHQ9IjEyIiBmaWxsPSIjMDAwIj4KICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9Im9wYWNpdHkiIHZhbHVlcz0iMTswIiB0aW1lcz0iMDsxIiBkdXI9IjFzIiBiZWdpbj0iLTAuNDE2NjY2NjY2NjY2NjY2N3MiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIj48L2FuaW1hdGU+CiAgPC9yZWN0Pgo8L2c+PGcgdHJhbnNmb3JtPSJyb3RhdGUoMjEwIDUwIDUwKSI+CiAgPHJlY3QgeD0iNDciIHk9IjI0IiByeD0iOS40IiByeT0iNC44IiB3aWR0aD0iNiIgaGVpZ2h0PSIxMiIgZmlsbD0iIzAwMCI+CiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJvcGFjaXR5IiB2YWx1ZXM9IjE7MCIgdGltZXM9IjA7MSIgZHVyPSIxcyIgYmVnaW49Ii0wLjMzMzMzMzMzMzMzMzMzMzNzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSI+PC9hbmltYXRlPgogIDwvcmVjdD4KPC9nPjxnIHRyYW5zZm9ybT0icm90YXRlKDI0MCA1MCA1MCkiPgogIDxyZWN0IHg9IjQ3IiB5PSIyNCIgcng9IjkuNCIgcnk9IjQuOCIgd2lkdGg9IjYiIGhlaWdodD0iMTIiIGZpbGw9IiMwMDAiPgogICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0ib3BhY2l0eSIgdmFsdWVzPSIxOzAiIHRpbWVzPSIwOzEiIGR1cj0iMXMiIGJlZ2luPSItMC4yNXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIj48L2FuaW1hdGU+CiAgPC9yZWN0Pgo8L2c+PGcgdHJhbnNmb3JtPSJyb3RhdGUoMjcwIDUwIDUwKSI+CiAgPHJlY3QgeD0iNDciIHk9IjI0IiByeD0iOS40IiByeT0iNC44IiB3aWR0aD0iNiIgaGVpZ2h0PSIxMiIgZmlsbD0iIzAwMCI+CiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJvcGFjaXR5IiB2YWx1ZXM9IjE7MCIgdGltZXM9IjA7MSIgZHVyPSIxcyIgYmVnaW49Ii0wLjE2NjY2NjY2NjY2NjY2NjY2cyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZT4KICA8L3JlY3Q+CjwvZz48ZyB0cmFuc2Zvcm09InJvdGF0ZSgzMDAgNTAgNTApIj4KICA8cmVjdCB4PSI0NyIgeT0iMjQiIHJ4PSI5LjQiIHJ5PSI0LjgiIHdpZHRoPSI2IiBoZWlnaHQ9IjEyIiBmaWxsPSIjMDAwIj4KICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9Im9wYWNpdHkiIHZhbHVlcz0iMTswIiB0aW1lcz0iMDsxIiBkdXI9IjFzIiBiZWdpbj0iLTAuMDgzMzMzMzMzMzMzMzMzMzNzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSI+PC9hbmltYXRlPgogIDwvcmVjdD4KPC9nPjxnIHRyYW5zZm9ybT0icm90YXRlKDMzMCA1MCA1MCkiPgogIDxyZWN0IHg9IjQ3IiB5PSIyNCIgcng9IjkuNCIgcnk9IjQuOCIgd2lkdGg9IjYiIGhlaWdodD0iMTIiIGZpbGw9IiMwMDAiPgogICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0ib3BhY2l0eSIgdmFsdWVzPSIxOzAiIHRpbWVzPSIwOzEiIGR1cj0iMXMiIGJlZ2luPSIwcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZT4KICA8L3JlY3Q+CjwvZz48L3N2Zz4=\");\r\n复制代码2、内联节点中使用 backgorund-image\r\n<view style=\"background-image: url(example.png)\">\r\n</view>\r\n复制代码这个方法我就不该说出来~ 因为在真机是无效的。。。（欲哭无泪）\r\n3、使用 image\r\n这个方法我也懒得详细贴demo了， 总之就是使用 image 改改样式设置到底部即可。\r\n<view>\r\n  <image src=\"example.png\" />\r\n</view>\r\n复制代码最后：现在的项目本地图片使用是非常少的，反正我见过的项目最多也就几张。 所以设置背景图片最简单的方法就是使用base64。\r\n5、object-fit无效\r\n在h5中使用 object-fit 特性是非常多的，它可以对图片保持一定的比例，而不会发生变形， 如果想了解其具体内容到 MDN\r\n在小程序中对图片使用此特性是没有效果的\r\n.image {\r\n  object-fit: cover;\r\n}\r\n复制代码解决这个问题也很简单，使用小程序自带的属性即可\r\n<image src=\"example.png\" mode=\"aspectFill\"></image>\r\n复制代码具体属性可到官方查看 mode属性一览\r\n6、小程序mock数据\r\n在WEB开发中我们会使用 mockjs 进行拦截请求从而模拟数据。\r\n在小程序中也可以使用吗？  那当然了， 只不过要对小程序 wx.request 处理。\r\n1、安装 mockjs\r\nnpm i mockjs\r\n复制代码2、新建 wxMock.js\r\n// 有点水平的应该能看得懂\r\n// 微信底层API都是不能重写的，所以用到 defineProperty 将其设置可写\r\n// 之后重写了底层 wx.request 方法，然后做些处理即可\r\n\r\nconst __request = wx.request;\r\nconst Mock = require('mockjs');\r\n\r\nObject.defineProperty(wx, 'request', { writable: true });\r\n\r\nwx.request = function (config) {\r\n  if (typeof Mock._mocked[config.url] === 'undefined') {\r\n    __request(config);\r\n    return;\r\n  }\r\n\r\n  const resTemplate = Mock._mocked[config.url].template;\r\n  const response = Mock.mock(resTemplate);\r\n\r\n  if (typeof config.success === 'function') {\r\n    config.success(response)\r\n  }\r\n  \r\n  if (typeof config.complete === 'function') {\r\n    config.complete(response)\r\n  }\r\n};\r\n\r\nmodule.exports = Mock;\r\n复制代码3、使用 wxMock.js\r\nconst Mock = require('wxMock.js')\r\n\r\n// 平常怎么用的就怎么用\r\nMock.mock('/api/example', {\r\n  data: { ... }\r\n})\r\n复制代码4、在app.js入口文件中引入mock\r\nimport \"./mock/index.js\";\r\n复制代码7、图片宽度100%，高度无法自适应\r\n在WEB开发中当把图片设置 100% 时，高度会自适应。\r\n小程序就是不行，不行你看：\r\n\r\n因为小程序底层已经对 image 添加了宽高了，所以默认就是 240px。\r\n解决方法是给 image 元素添加 mode 属性\r\n<image src=\"example.png\" mode=\"widthFix\"></image>\r\n复制代码当添加此模式并给图片设置 100% 宽度后，小程序自动计算其高度，就可以让图片自适应了。\r\n\r\n8、properties 能定义多个类型吗？\r\n我只能先说可以。\r\n此特性是小程序基础库2.6.5新增的，可能有些小伙伴不知道。\r\noptionalTypes 字段是个数组，指定属性类型，可以多个。\r\nComponent({\r\n  properties: {\r\n    lastLeaf: {\r\n      // 这个属性可以是 Number 、 String 、 Object 三种类型中的一种\r\n      type: Number,\r\n      optionalTypes: [String, Object],\r\n      value: 0\r\n    }\r\n  }\r\n})\r\n复制代码9、跳转到tabbar无法返回上一层\r\n这个问题我估计每一个开发者都经历过。\r\n常规页面跳转到 tabbar 页面只能使用 wx.switchTab ，此API有个问题是：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面\r\n所以当跳转到 tabbar 页面左上角返回键自然就没了，所以是无法返回上一层的。\r\n用得比较多的场景就是购物车了， 某个页面跳转到购物车不可以返回上一层那体验不是很差么。\r\n这个问题我就不贴demo了，说下其方案。\r\n\r\n自定义导航头部，新增一个返回键\r\n自定义 tabbar 组件， 这个时候就不存在什么 switchTab 跳转了\r\n将购物车页面封装成一个组件，然后新建2个页面，一个作为tabbar，一个作为常规页面，目前jd使用这种方案。\r\n\r\n总结\r\n微信小程序开发和 web 还是有一些区别的， 小程序的开发灵活度虽然现在没有那么高，但随着不断的迭代更新，会慢慢得到改善，并受到众多开发者的喜爱。\r\n这篇文章不会断更，只要有些好的技巧会总结下来并分享。 \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "【微信小程序】分享朋友圈组件开发实践 ", "author": "Rolan", "time": "2020-4-16 00:41", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    背景在一个完整带用户交互的小程序项目开发中，总会遇到分享这个功能，转发给好友用通用的api方法，分享朋友圈总是有各种各样的招式，一般的交互方案是生成一个带二维码的图，二维码有时候也分带参数和默认的。分享一个前段时间开发的生成分享图的功能，我当时的业务二维码是带参数的，为了识别能定位到固定产品页(生成带参数二维码是用微信云调用提供的方法处理，点此看帖分享图用canvas画布开发，所以对wx封装的canvas相关api要有一定了解开发步骤新建一个share组件文件包，并开发业务逻辑和样式编写含小程序规范的几个文件js/wxml/wxss/json开发代码，在需要引用页面的对应配置文件中加入组件配置在引用的wxml中加入组件代码和传参，js文件写参数的交互效果图代码概览1.share / share.wxml 【参考效果图 步骤2/3备注：1.第一模块 步骤2的分享引导层，点击分享票圈，出来第二模块弹框2.第二模块 步骤3效果图，share-load.gif是一个加载中动画的gif；close.png是关闭图标<!--分享弹窗--><view class=\"share-wrap\" bindtap=\"toClose\">  <!-- 分享的引导层 分 转发票圈或好友 -->  <view class=\"share-mod\" catchtap=\"doNothing\">    <view class=\"share-hd\">      <text class=\"fl\">分享</text>      <image class=\"share-close\" catchtap=\"toClose\" src=\"../../images/icons/close.png\"></image>    </view>    <view class=\"share-guide\">      <view class=\"share-wx\">          <button class=\"share-btn\" open-type=\"share\"></button>          <image src=\"../../images/icons/wx_friend.png\"></image>          <text>分享给好友</text>      </view>      <view class=\"share-line\"></view>      <view class=\"share-wx\" catchtap=\"toShowShareImg\">        <image src=\"../../images/icons/wx_quan.png\"></image>        <text>生成分享海报</text>      </view>    </view>  </view>  <!-- 点击引导层的 转发票圈 触发的生成画布图弹层 -->  <view class=\"share-mod\" hidden=\"{{!showShareImg}}\" catchtap=\"doNothing\">    <view class=\"share-hd\">      <text class=\"fl\">保存到相册</text>      <image class=\"share-close\" catchtap=\"toCloseShareImg\" src=\"../../images/icons/close.png\"></image>    </view>    <view class=\"share-quan\">      <image wx:if=\"{{imgSrc!=''}}\" class=\"share-img\" src=\"{{imgSrc}}\"></image>      <view wx:else>        <image class=\"share-img-load\" src=\"../../images/icons/share-load.gif\"></image>        <text class=\"share-load-text\">{{loadText}}</text>      </view>      <view class=\"save-btn\" catchtap=\"saveImg\">保存图片</view>      <view class=\"save-tip\">保存图片到手机相册后，就可以分享至您的圈子啦</view>    </view>  </view></view>2.share/ share.json{  \"component\": true}3.share/ share.js/*  使用说明↓↓↓1.需要引用的页面json配置文件新增如下配置项\"usingComponents\": {  \"share-win\": \"/component/share/share\"}2.页面wxml文件使用如下 shareInfo格式说明见下文 该组件是否渲染根据该对象是否有具体数据<canvas canvas-id=\"shareCanvas\" style=\"position:fixed;top:0;left:999rpx;width:1000px;height:750px;\"></canvas><share-win share-info=\"{{shareInfo}}\" bindcloseshare=\"closeShareWin\"></share-win>3.页面对应js需要定义一个closeshare事件[由组件里的toClose触发] 内部主要是将shareInfo参数置空4.shareInfo格式*/Component({  properties: {    shareInfo: {      type: Object,      value: {},    }  },  data: {    imgSrc:'',    showShareImg:false,    hasDownload:false,    loadText:'分享图绘制准备中...'  },  ready:function(){  },  methods: {    //点击浮层区域关闭弹窗    toClose:function(){      this.toCloseShareImg();      this.triggerEvent(\"closeshare\")    },    toCloseShareImg:function(){      this.setData({        showShareImg:false      })      if(this.data.hasDownload){        this.triggerEvent(\"closeshare\")      }    },    toShowShareImg:function(){      this.setData({        showShareImg:true      })      this.renderShareImg();    },    doNothing:function(){      return false;    },    setLoadText:function(txt){      this.setData({        loadText:txt      })    },    //渲染分享图    renderShareImg:function(){      //1000x750      const _this = this;      const _obj = _this.data.shareInfo;      //默认题图      let promise1 = new Promise(function (resolve, reject) {        if(_obj.cover==undefined || _obj.cover==''){          _obj.cover = '../../images/share_default.jpg'          resolve({path:_obj.cover});        }else{          _obj.cover = \"https://\"+_obj.cover.split('\\/\\/')[1]          wx.getImageInfo({            src: _obj.cover,            success: function (res) {              resolve(res);            }, fail: function (error) {              console.log(error);              _obj.cover = '../../images/share_default.jpg'              resolve({path:_obj.cover});            }          })        }      });      //小程序码      let promise2 = new Promise(function (resolve, reject) {        wx.cloud.callFunction({          name: 'openapi',          data: {            action:'getWXACodeUnlimit',            page: 'pages/detail/detail',            width: 220,            scene: _obj.id+\"_\"+_obj.goodsId,          },          success: res => {            wx.getImageInfo({              src: res.result[0].tempFileURL,              success: function (suc) {                resolve(suc);              }, fail: function (error) {                resolve({path:\"../../images/qrcode.jpg\"})                console.log(error)              }            })              },          fail: error => {            console.log(JSON.stringify(error))            resolve({path:\"../../images/qrcode.jpg\"})          }        });      });      //加载所有完图片后绘制画布      Promise.all(        [promise1,promise2]      ).then(res => {        //绘制头图的圆角效果        const ctx = wx.createCanvasContext('shareCanvas')        ctx.setFillStyle('#ffffff');        ctx.fillRect(0, 0, 750, 1125);        //绘制题图        _this.setLoadText(\"绘制商品图...\")        ctx.drawImage(res[0].path, 25, 25, 700, 700)       // ...删除了部分 绘制逻辑代码...        //绘制小程序码        _this.setLoadText(\"绘制小程序码...\")        ctx.drawImage(res[1].path, 35, 874, 228, 228);        //画布绘制完成转图片，将地址赋值给图片        _this.setLoadText(\"分享图生成中...\")        ctx.draw();        setTimeout(function () {          wx.canvasToTempFilePath({            width: 750,            height: 1125,            destWidth: 750,            destHeight: 1125,            quality: 1,            canvasId: 'shareCanvas',            success: function (res) {              // console.log(\"canvasToTempFilePath success:\"+res.tempFilePath);              wx.hideLoading({})              _this.setData({                imgSrc: res.tempFilePath,                shareShow: true              })            },            fail: function (res) {            }          })        }, 200)      })    },    //保存图片    saveImg:function(){      //下载文件      const _this = this;      if(_this.data.imgSrc==''){        wx.showToast({          title:\"分享图还在生成中...\",          icon: 'none',          duration:3000        })        return false;      }      wx.saveImageToPhotosAlbum({        filePath: _this.data.imgSrc,        success(res) {          wx.showToast({            title:\"已保存至相册，可以分享啦\",            icon: 'none',            duration:3000          })          _this.setData({            hasDownload:true          })        }      })    },    //图片按比例居中裁剪    calClipImg(oW,oH,mW,mH){      var oR = parseFloat(oW/oH).toFixed(5);      var mR = parseFloat(mW/mH).toFixed(5);      if(oR == mR){        return [0,0,oW,oH]      }else if(oR > mR){        var ratio = parseFloat(mH/oH).toFixed(5);        return [((oW*ratio-mW)/2)/ratio,0,mW/ratio,mH/ratio];      }else{        var ratio = mW/oW;        return [0,((oH*ratio-mH)/2)/ratio,mW/ratio,mH/ratio];      }    },    //绘制圆角    roundRect(x, y, w, h, r,ctx){      var min_size = Math.min(w, h);      if (r > min_size / 2) r = min_size / 2;      // 开始绘制      ctx.beginPath();      ctx.moveTo(x + r, y);      ctx.arcTo(x + w, y, x + w, y + h, r);      ctx.arcTo(x + w, y + h, x, y + h, r);      ctx.arcTo(x, y + h, x, y, r);      ctx.arcTo(x, y, x + w, y, r);      ctx.closePath();    },    //绘制文本方法    drawText(str,ctx,initX,initY,lineHeight,minusW,maxLine){      var curLine = 1;      var lineWidth = 0;      var canvasWidth = 750;      var lastSubStrIndex= 0;      var d = 0;      for(var i=0;i<str.length;i++){        lineWidth += ctx.measureText(str[i]).width;        //判断当前文字行是否超过一行 [减minusW,防止边界溢出]        if((d==0 && lineWidth>canvasWidth-minusW)||(d>0 && ((lineWidth>=canvasWidth-minusW) || ((lineWidth+ctx.measureText(str[i+1]).width)>canvasWidth-minusW)))){          d++;          ctx.fillText(str.substring(lastSubStrIndex,i),initX,initY);          initY+=lineHeight;          lineWidth=0;          lastSubStrIndex=i;          curLine = curLine+1;          if(maxLine!=-1 && curLine>maxLine)break; //最多绘制六行        }        //最后一个字的时候 绘制一行        if(i==str.length-1){          ctx.fillText(str.substring(lastSubStrIndex,i+1),initX,initY);        }      }    }  }})4.share.wxss.share-wrap{  position:fixed;  top:0;  width:750rpx;  height:100%;  background:rgba(0,0,0,.4);  overflow: hidden;  z-index:1001;}.share-mod{  position:fixed;  bottom:0;  width:100%;  background:#fff;  z-index:1001;  overflow: hidden;}.share-mod .share-hd{  padding-left:20rpx;  height:80rpx;  line-height:80rpx;  background:#efefef;  color:#666;  font-size:32rpx;}.share-mod .share-close{  float:right;  margin:15rpx 20rpx;  height:50rpx;  width:50rpx;}.share-guide{  padding:35rpx;  width:680rpx;  height:180rpx;}.share-guide .share-wx,.share-guide .share-line{  float:left;}.share-guide .share-line{  margin-top:60rpx;  height:160rpx;  width:1rpx;  color:#cdcdcd;}.share-guide .share-wx{  width:339rpx;  height:180rpx;  text-align:center;  font-size:24rpx;}.share-guide .share-wx image{  display: block;  margin:20rpx auto;  padding:10rpx;  width:64rpx;  height:64rpx;  border-radius:43rpx;  border:1rpx solid #dedede;}.share-guide .share-btn{  position: absolute;  margin:0;  padding:0;  bottom:40rpx;  left:35rpx;  width:340rpx;  height:180rpx;  background:none;}.share-guide .share-btn:after{  border:none;}.share-quan{  margin:20rpx;  overflow: hidden;}.share-quan .share-img{  display:block;  margin:10rpx auto 28rpx;  height:600rpx;  width:400rpx;  border-radius:8rpx;  box-shadow:0 0 10rpx #cdcdcd;}.share-quan .share-img-load{  display:block;  margin:260rpx auto 20rpx;  height:80rpx;  width:80rpx;}.share-quan .share-load-text{  margin:0 auto 220rpx;  display:block;  widows:100%;  text-align:center;  font-size:28rpx;  color:#b7b7b7;}.share-quan .save-btn{  width:710rpx;  height:80rpx;  line-height:80rpx;  color:#fff;  text-align:center;  letter-spacing:4rpx;  background-color:#e2633f;  border-radius:6rpx;  font-size:34rpx;}.share-quan .save-tip{  margin:18rpx;  text-align:center;  font-size:24rpx;}↓组件开发已经完成，接下去是组件的使用↓1.demo.json备注：usingComponents加入对应组件配置即可{  \"navigationBarBackgroundColor\": \"#ffffff\",  \"navigationBarTextStyle\": \"black\",  \"navigationBarTitleText\": \"xxx\",  \"usingComponents\": {    \"share-win\": \"/component/share/share\"  }}2.demo.wxml备注：点击分享按钮的时候 showShareWin值改变，shareInfo根据渲染需求赋值<view>    <!-- S 其他业务代码 -->    <!-- E 其他业务代码 -->    <!-- 分享 -->    <canvas canvas-id=\"shareCanvas\" style=\"position:fixed;top:0;left:999rpx;width:750px;height:1125px;\"></canvas>    <share-win wx:if=\"{{showShareWin}}\" share-info=\"{{shareInfo}}\" bindcloseshare=\"closeShareWin\"></share-win></view>3.demo.js备注：删除了其他业务代码，仅剩和分享的交互，便于阅读。shareInfo数据在load时就塞进去了，下面没有放出来~Page({  data: {    showTop:false  },  //点击右侧悬浮的分享按钮  doShare:function(){    this.setData({      showShareWin:true    })  }, //触发关闭分享弹框  closeShareWin:function(){    this.setData({      showShareWin:false    })  },})其他说明:步骤4为最终生成效果图，微信识别二维码就可定位到具体业务页~有问题可留言交流~完... \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "小程序瘦身之利用gulp压缩wxss ", "author": "Rolan", "time": "2020-4-16 00:51", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                     前言众所周知，微信小程序在发布的时候，对提交的代码是有大小的限制！项目内容太多的时候我们就需要想办法去做一些优化。首先先打开自己项目的文件夹，看看体积最大的是什么，然后在针对它去做一些措施，由于我现在的项目体积最大的基本都是wxss，所以现在主要谈谈如何利用glup来压缩wxss（使用的是微信原生，瞎捉摸的，仅适用于小白，有更好的办法欢迎评论里讨论）华丽的分隔线，前面的碎碎念可以略过，下面才是正文。正文安装gulp1、全局安装cnpm install gulp -g2、检查版本gulp -v在微信小程序中使用先把微信所有项目都塞到一个文件夹使用cmd打开根目录，npm init 创建package.json在更目录下安装gulp-clean-css，压缩CSS文件cnpm install gulp-clean-css -D目录下新建 gulpfile.js 文件，最后文件夹有这些东西gulpfile.js 文件内容var gulp = require('gulp'); // 载入Gulp模块var cleanCss = require('gulp-clean-css');  //加载clean模块  压缩css//定义一个压缩css代码的任务,定义一个cleanCss任务，自定义任务名gulp.task('cleanCss', (cb) => {    console.log('执行压缩!');    gulp.src('./src/pages/index/*.wxss')  //找到原始文件        .pipe(cleanCss())    //压缩css代码        .pipe(gulp.dest('./src/pages/index/min_after'));  //压缩后的代码储存在这里    cb();});执行命令结果 \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "小程序input的一些坑点 ", "author": "Rolan", "time": "2020-4-15 00:31", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    最近在开发中遇到的一些坑点\r\n\r\n表单组件(input)如何阻止冒泡\r\n在容器(fixed)中的input如何弹出键盘\r\n\r\n阻止input冒泡\r\n<view bind:tap=\"onTap\" class=\"container\">\r\n    <input bindinput=\"onBindInput\" type=\"text\"/>\r\n</view>\r\n复制代码上例中input操作会冒泡到container，导致onTap响应执行\r\n修正\r\n<view bind:tap=\"onTap\" class=\"container\">\r\n    <input bindinput=\"onBindInput\" type=\"text\" catch:tap=\"empty\"/>\r\n</view>\r\n复制代码冒泡的问题是由input的tap事件导致，因此定义一个empty的空方法，使它响应input的catch:tap，来达到阻止input的冒泡的作用\r\n在容器(fixed)中的input如何弹出键盘\r\n<view class=\"container\" style=\"position: fixed; bottom: 0\">\r\n    <input bindinput=\"onBindInput\" type=\"text\"/>\r\n</view>\r\n复制代码container组件在屏幕底部出现，点击Input组件时，弹出的键盘会遮盖input输入框\r\n修正\r\n<view class=\"container\" style=\"position: fixed; bottom: 0; {{mystyle}}\">\r\n    <input bindinput=\"onBindInput\" bindkeyboardheightchange=\"onkeybord\" type=\"text\"/>\r\n</view>\r\n复制代码Page({\r\n    data: {\r\n        mystyle: '',\r\n    },\r\n    \r\n    onkeybord(e){\r\n        let detail = e.detail\r\n        let kbHeight = detail.height\r\n        let tool = Pager.getElementsById('reminder-tool')\r\n        if (kbHeight === 0) {\r\n          this.setData({\r\n              mystyle: ' '\r\n          })\r\n        }\r\n\r\n        if (kbHeight && kbHeight > 0) {\r\n            this.setData({\r\n                mystyle: `bottom: ${kbHeight-40}px;`\r\n            })\r\n        }\r\n    }\r\n})\r\n复制代码demo\r\n \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "小程序集成eslint和prettier，代码风格统一 ", "author": "Rolan", "time": "2020-4-14 00:21", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    微信小程序、支付宝小程序、钉钉小程序都可以适用LZ用的是钉钉小程序，很完美首先你要有vscode这个首先目录结构是这样的一定要src里面放小程序的文件夹，如果全部放在一起，会导致小程序上传过大的问题，我刚开始就吃了这个坑，居然打包了40多m，根本传不上去，后来放在src文件夹下面就解决了，让小程序直接去访问src文件夹{\r\n  \"private\": true,\r\n  \"name\": \"dingproject\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"app.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\r\n    \"precommit\": \"lint-staged\",\r\n    \"clean\": \"rm -rf dist/*\",\r\n    \"lint\": \"eslint -c .eslintrc ./src\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"dependencies\": {},\r\n  \"devDependencies\": {\r\n    \"babel-eslint\": \"^8.2.1\",\r\n    \"eslint\": \"^3.12.1\",\r\n    \"eslint-config-prettier\": \"^2.9.0\",\r\n    \"eslint-plugin-html\": \"^3.0.1\",\r\n    \"eslint-plugin-import\": \"^2.8.0\",\r\n    \"eslint-plugin-prettier\": \"^2.3.1\",\r\n    \"lint-staged\": \"^6.0.0\",\r\n    \"prettier\": \"^1.8.2\"\r\n  },\r\n  \"lint-staged\": {\r\n    \"src/**/*.js\": [\r\n      \"eslint --fix\",\r\n      \"git add\"\r\n    ]\r\n  }\r\n}.eslintrc 文件{\r\n    \"extends\": [\r\n      \"prettier\",\r\n      \"prettier/standard\"\r\n    ],\r\n    \"useTabs\": false,\r\n    //插件\r\n    \"plugins\": [\r\n      \"prettier\"\r\n    ],\r\n   \r\n    //配置解析器\r\n    \"parser\":\"babel-eslint\",\r\n    \"parserOptions\": {\r\n      \"ecmaVersion\": 6,\r\n      \"sourceType\":\"module\",\r\n    },\r\n   \r\n    \"env\": {//脚本目标的运行环境\r\n      \"browser\":true,\r\n      \"node\":true,\r\n      \"es6\":true,\r\n      \"commonjs\":true\r\n    },\r\n   \r\n    //全局变量\r\n    \"globals\": {\r\n\"__DEV__\":true,\r\n\"__WECHAT__\":true,\r\n\"__ALIPAY__\":true,\r\n\"App\":true,\r\n\"Page\":true,\r\n\"Component\":true,\r\n\"Behavior\":true,\r\n\"wx\":true,\r\n\"getApp\":true,\r\n    },\r\n   \r\n    //规则，只用插件：插件名/规则\r\n    \"rules\": {\r\n\"prettier/prettier\":\"error\",\r\n\"no-console\": 0\r\n    }\r\n  }然后 npm i 安装一下即可npm run lint如何让vscode 可以保存自动并校准文件，可以参考我下一篇文章如何让eslint自动保存并修改不合规范的文件 \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "微信小程序仿Material Design风格的下拉刷新组件 ", "author": "Rolan", "time": "2020-4-14 00:29", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    在微信小程序开发中实现下拉刷新最简单的方式就是在页面对应的json文件中添加enablePullDownRefresh:true，然后在Page.onPullDownRefresh 方法中执行刷新逻辑。这种方式有一些局限性，一是无法自定义下拉刷新效果，只能使用默认的“三个圆点”样式；二是下拉刷新的视图位置是固定在顶部的，如果要刷新的视图元素不是位于页面顶部，那么使用这种方式就不太好了，最常见的场景就是顶部Tab标签栏，下面是要刷新的列表。在小程序基础库版本2.10.1之后，scroll-view支持自定义下拉刷新了，很好地解决了上述的两个问题，缺点当然就是兼容性了。于是想着自己实现一个下拉刷新组件，由于我本身是做Android开发的，所以尝试实现了一个仿Material Design风格的下拉刷新效果（Android中的SwipeRefeshLayout），先附上一张效果图：虽然没能做到百分之百的还原，不过基本功能还是实现了的。相关代码我已经上传到了github。使用方式将组件拷贝到项目中，在页面的json文件中引入，这里就不展示了。组件可设置的属性如下：此外，组件还定义了一个setRefresh()函数，用于设置刷新状态，参数传入一个布尔值，true表示开始刷新，显示下拉刷新圆圈；false表示结束刷新，隐藏下拉刷新圆圈。示例代码如下：index.wxml<swipe-refresh-layout id='refresh' style='width:100vw;height:200rpx;' loadMoreEnable bindrefresh='refresh' bindloadmore='loadMore'>  <!-- 要刷新的内容 --></swipe-refresh-layout>index.jsPage({  /**   * 页面的初始数据   */  data: {},  /**   * 生命周期函数--监听页面加载   */  onLoad: function(options) {    this.swipeRefresh = this.selectComponent('#refresh');  },  /**   * 下拉刷新   */  refresh: function() {    // 模拟获取数据    setTimeout(() => {      // 结束下拉刷新      this.swipeRefresh.setRefresh(false);    }, 3000);  },  /**   * 上拉加载   */  loadMore: function() {    // ...  }})需要注意，使用时必须给swipe-refresh-layout组件一个固定的宽度和高度。实现原理实现原理还是比较简单的，大体上就是通过监听触摸事件，在touchstart事件回调中记录手指按下的坐标；在touchmove事件回调中计算手指在竖直方向上的滑动距离，通过css的transform属性实现下拉刷新圆圈的移动；在touchend事件回调中计算手指抬起时的滑动距离，如果向下的滑动距离超过阈值就触发下拉刷新事件，否则将下拉刷新圆圈归位。由于在滑动的过程中需要频繁地进行用户交互，出于性能方面的考虑，我使用了WXS函数用来响应触摸事件，将事件定义在视图层，解决视图层和逻辑层间通信耗时的问题。虽然整体的实现逻辑不难理解，但是在开发过程中我还是遇到了几个问题，这里简单介绍一下。touchmove导致的卡顿问题一开始我使用的是bindtouchmove属性监听手指滑动事件，在开发工具上测试时没有什么问题，后来运行在安卓真机上才发现手指触摸屏幕下拉时刷新圆圈的移动比较卡顿，不流畅。在微信开放社区查了一下这个问题，发现也有人遇到过，目前的解决方案就是将bindtouchmove改为catchtouchmove。具体原因还不清楚，可能是官方的bug吧，又或者小程序本身就是这样设计的。改为catchtouchmove后确实是解决了下拉卡顿的问题，但是同时会导致页面内容无法滑动，如何解决这个问题呢，我们不妨考虑一下具体的使用场景，正常情况下只有在页面内容处于顶部时才可以下拉刷新，可以利用这个条件来判断是否需要我们自己处理touchmove事件。具体的做法是这样的，首先在组件最外层使用scroll-view，通过bindscroll监听滑动事件：_scroll: function(e) {  if (e.detail.scrollTop <= 50) {    // 滚动到顶部    this.setData({      scrollTop: true    });  } else {    this.setData({      scrollTop: false    });  }}使用一个变量scrollTop来记录是否滑动到了顶部，这里的判断条件为什么是e.detail.scrollTop <= 50而不是e.detail.scrollTop <= 0呢，因为通过测试我发现有时页面滑动到顶部时e.detail.scrollTop的值并不是0，而是一个接近0的整数，为了保证每次页面滑动到顶部都能改变scrollTop的状态，这里就给了一个默认值，取50是因为官方文档上给出的默认阈值就是50。之后在catchtouchmove回调函数中根据scrollTop的值判断是否需要处理滑动事件，如果scrollTop的值为false（页面内容不处位于顶部）就直接return。touchmove: function(e) {  if (!this.data.scrollTop) {    return;  }  // 处理滑动事件  }这样就解决了页面内容始终无法滚动的问题，当然上面的代码只是简单地说明解决方法，详细内容可以参考组件的源码。下拉刷新圆圈的显示层级问题正常情况下下拉刷新圆圈是位于要刷新的内容之上的，并且不会随着内容的滑动而移动，我们很容易就想到使用position:fixed属性，通过z-index属性来设置元素的层叠顺序。但是如果下拉刷新圆圈的z-index指定一个大于0的数，而刷新组件又不是位于页面的顶部，就会导致下拉刷新圆圈始终会显示出来，如下图所示：我这里采取的解决方案就是将下拉刷新圆圈的z-index指定为-1，而刷新内容的z-index指定为-2（取值不是固定的，只要比下拉刷新圆圈的小就可以），这样就可以解决下拉刷新圆圈覆盖在页面普通视图之上的问题。当然我的解决方案可能不是最好的，或者存在一些问题，如果大家有自己的想法欢迎提出，一起交流。总结目前我对于微信小程序的研究还比较浅显，对于CSS属性的运用也不是很熟练，可能组件本身还存在一些问题，或者大家还有更好的实现方案，欢迎提出。最后附上Demo地址，大家可以进行参考。参考文章极致的scroll-view的下拉刷新扩展组件 \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "微信小程序云开发—云函数连接MySQL ", "author": "Rolan", "time": "2020-4-13 00:27", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    微信小程序云开发—云函数连接MySQL本文章代码已上传GitHub：\thttps://github.com/aquanlerou/miniprogram-cloud-development直接上干货，主要是利用微信的云函数和\tSequelize 进行连接外部\tMySQL ，本文章主要讲述：MySQL\r\nMySQL\r\n注：微信小程序APPID（请自行去地址注册\thttps://mp.weixin.qq.com ）拉取我的代码或则创建一个新的云开发小程序//本文章主要的代码在一下目录中\r\nminiprogram-cloud-development\r\n ├── cloudfunctions\r\n │   └── mysql\r\n ├── miniprogram\r\n │   └── pages\r\n │       └── mysql\r\n ├── project.config.json\r\n └── README.md选择已经配置好的\tmysql 页面编译模式，在编译器中直接打开\tMySQL 页面我们页面代码也只需要一行代码，按钮进行触发云函数即可。mysql.wxml<button bindtap=\"mysql\">mysql</button>mysql.jsPage({\r\n    mysql: function(event) {\r\n        console.log(event)\r\n\t\t//调用云函数\r\n        wx.cloud.callFunction({\r\n            name: 'mysql' //调用我们后面写的mysql云函数对应命名\r\n        }).then(res => {\r\n            console.log(res)\r\n        })\r\n    }\r\n})这是我们前端看到的页面了，就一个按钮触发云函数的页面就写好了。创建连接MySQL云函数可以看到我的代码中已经创建好一个叫\tmysql 的\tindex.js 云函数如下const cloud = require('wx-server-sdk')\r\n\r\nconst Sequelize = require('sequelize')\r\n// const sequelize = new Sequelize('数据库名称', '用户名', '密码', {\r\nconst sequelize = new Sequelize('xx', 'xx', 'xx', {\r\n    host: '119.28.161.110',//云数据库IP地址\r\n    port: 3306,\r\n    dialect: 'mysql',\r\n    operatorsAliases: false,\r\n    pool: {\r\n        max: 5,\r\n        min: 0,\r\n        acquire: 30000,\r\n        idle: 10000\r\n    }\r\n})\r\n\r\n//创建USER表，表结构为一个firstName和lastName字段同为String类型\r\nconst User = sequelize.define('user', {\r\n    firstName: {\r\n        type: Sequelize.STRING\r\n    },\r\n    lastName: {\r\n        type: Sequelize.STRING\r\n    }\r\n})\r\n\r\ncloud.init()\r\n\r\nexports.main = async (event, context) => {\r\n\t\r\n    //这里进行调用创建USER表，并且插入一条数据，最后返回结果给调用者。\r\n    return await User.sync({ force: true }).then(() => User.create({\r\n        firstName: 'Huangquan',\r\n        lastName: 'Wu'\r\n    })).then(res => {\r\n        return res.toJSON()\r\n    })\r\n\r\n}Sequelize 的文档地址：\thttps://sequelize.org/v4/下面我们要在个云函数\tminiprogram-cloud-development\\cloudfunctions\\mysql 目录打开终端，安装\tSequelize 的依赖Microsoft Windows [版本 6.1.7601]\r\n版权所有 (c) 2009 Microsoft Corporation。保留所有权利。\r\n\r\nD:\\Git\\miniprogram-cloud-development\\cloudfunctions\\mysql>npm install --save sequelize\r\nnpm notice created a lockfile as package-lock.json. You should commit this file.\r\nnpm WARN mysql@1.0.0 No description\r\nnpm WARN mysql@1.0.0 No repository field.\r\n\r\n+ sequelize@5.21.6\r\nadded 21 packages from 93 contributors and audited 22 packages in 7.577s\r\nfound 0 vulnerabilities\r\n\r\n\r\nD:\\Git\\miniprogram-cloud-development\\cloudfunctions\\mysql>npm install --save mysql2\r\nnpm WARN mysql@1.0.0 No description\r\nnpm WARN mysql@1.0.0 No repository field.\r\n\r\n+ mysql2@2.1.0\r\nadded 19 packages from 21 contributors and audited 41 packages in 10.162s\r\nfound 0 vulnerabilities\r\n\r\n\r\nD:\\Git\\miniprogram-cloud-development\\cloudfunctions\\mysql>安装好后我们需要把它同步到云开发的环境中，这里就不详细讲解怎么开通创建云开发环境了，可以自行在官方文档进行查找学习附上地址：\thttps://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html测试调用云函数我们只需要在预先设置的\tmysql 编译模式下后，点击我们的按钮观察控制台打印的结果，和数据库可视化工具是否创建了表和插入数据。可以看到我们远端的\tMySQL 数据库已经创建了\tUSER 表并且插入一条数据。总结个人比较推荐直接使用云开发自带的数据库，因为速度快，用外连\tMySQL 的话会收到网络波动的影响。就像我要把这个云函数的\t超时时间跳到15s \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "完整微信小程序授权登录页面教程 ", "author": "Rolan", "time": "2020-4-14 00:26", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    1、前言\r\n微信官方对getUserInfo接口做了修改，授权窗口无法直接弹出，而取而代之是需要创建一个button，将其open-type属性绑定getUseInfo方法。在参考了网路上各种方案之后，实现了用户在授权之后跳转到小程序首页的授权登录页面。\r\n2、实现效果\r\n\r\n\r\n3、实现思路\r\n在进入小程序时先对授权情况进行判断，若已经过授权则直接跳转到首页，若还未经过授权则进入授权页面，点击页面的授权按钮会弹出选择框，选择“拒绝”则不进行跳转，选择“允许“则进行授权并跳转到小程序首页。\r\n4、实现代码\r\n<!--login.wxml-->\r\n<view wx:if=\"{{canIUse}}\">\r\n  <view class='header'>\r\n    <image src='/assets/tasks_icon/check.png'></image>\r\n  </view>\r\n  <view class='content'>\r\n    <view>申请获取以下权限</view>\r\n    <text>获得你的公开信息(昵称，头像等)</text>\r\n  </view>\r\n  <button class='bottom' type='primary' open-type=\"getUserInfo\" lang=\"zh_CN\" bindgetuserinfo=\"bindGetUserInfo\">\r\n    授权登录\r\n  </button>\r\n</view>\r\n<view wx:else>请升级微信版本</view>\r\n复制代码//login.wxss\r\n.header {\r\n  margin: 90rpx 0 90rpx 50rpx;\r\n  border-bottom: 1px solid #ccc;\r\n  text-align: center;\r\n  width: 650rpx;\r\n  height: 300rpx;\r\n}\r\n\r\n.header image {\r\n  width: 200rpx;\r\n  height: 200rpx;\r\n}\r\n\r\n.content {\r\n  margin-left: 50rpx;\r\n  margin-bottom: 90rpx;\r\n}\r\n\r\n.content text {\r\n  display: block;\r\n  color: #9d9d9d;\r\n  margin-top: 40rpx;\r\n}\r\n\r\n.bottom {\r\n  border-radius: 80rpx;\r\n  margin: 70rpx 50rpx;\r\n  font-size: 35rpx;\r\n}\r\n复制代码//login.js\r\nPage({\r\n  data: {\r\n    //判断小程序的API，回调，参数，组件等是否在当前版本可用。\r\n    canIUse: wx.canIUse('button.open-type.getUserInfo')\r\n  },\r\n\r\n  onLoad: function () {\r\n    var that = this;\r\n    // 查看是否授权\r\n    wx.getSetting({\r\n      success: function (res) {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          wx.getUserInfo({\r\n            success: function (res) {\r\n              // 用户已经授权过,调用微信的 wx.login 接口，从而获取code,再直接跳转到主页\r\n              wx.login({\r\n                success: res => {\r\n                  // 获取到用户的 code 之后：res.code\r\n                  console.log(\"用户的code:\" + res.code);\r\n                }\r\n              });\r\n              wx.switchTab({\r\n                url: '/pages/home/home',    //这里填入要跳转目的页面的url\r\n                success: (result) => {\r\n                  console.log(\"跳转到首页\");\r\n                },\r\n                fail: () => {}\r\n              });\r\n            }\r\n          });\r\n        } else {\r\n          // 用户没有授权，显示授权页面,这里不进行操作\r\n        }\r\n      }\r\n    });\r\n  },\r\n\r\n  bindGetUserInfo: function (e) {\r\n    if (e.detail.userInfo) {\r\n      //用户按了允许授权按钮\r\n      var that = this;\r\n      // 获取到用户的信息了，打印到控制台上看下\r\n      console.log(\"用户的信息如下：\");\r\n      console.log(e.detail.userInfo);\r\n      //授权成功后,跳转页面\r\n      wx.switchTab({\r\n        url: '/pages/home/home',    //这里填入要跳转目的页面的url\r\n        success: (result) => {\r\n          console.log(\"跳转到首页\");\r\n        },\r\n        fail: () => {}\r\n      });\r\n    } else {\r\n      //用户按了拒绝按钮\r\n      wx.showModal({\r\n        title: '警告',\r\n        content: '您拒绝了授权，将无法进入小程序，请授权之后再进入!',\r\n        showCancel: false,\r\n        confirmText: '返回',\r\n        success: function (res) {\r\n          // 用户没有授权成功，不需要改变 isHide 的值\r\n          if (res.confirm) {\r\n            console.log('用户点击了“返回”');\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n})\r\n复制代码最后在app.json文件中将login设置为第一个页面即可。\r\n//app.json\r\n{\r\n\t\"pages\": [\r\n\t\t\"pages/login/login\",\r\n\t\t\"pages/home/home\"\r\n\t]\r\n} \r\n\r\n\r\n\r\n                鲜花                (1)\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "小程序数据埋点实践之曝光量 ", "author": "Rolan", "time": "2020-4-13 00:02", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    什么是数据埋点所谓数据埋点就是应用在规定流程中 对特定行为或事件进行数据采集 。使用采集的数据做用户分析和页面分析，可以获得应用的总体使用情况，为后续优化产品和运营提供数据支撑。常见数据埋点内容包括：访问量、停留时长、曝光量、点击量、跳出率等等。微信小程序也为我们提供了自定义分析统计，其中包括 API 上报（代码埋点），填写配置（无埋点，只需在公众后台配置）。而第三方统计平台比较有名的就是阿拉丁统计，只需引入集成的 SDK，开发成本低，能够满足大部分的需求。数据埋点需要分析页面流程，确定埋点需求，选择埋点方式。如果是代码埋点，主要关注触发时机、条件判断、捕获数据，其次要注意是否有遗漏的场景没有做到埋点。代码埋点虽然成本较大（侵入代码），但是精准度较高，能够很好的满足埋点需求。什么是曝光量曝光量顾名思义是 指定元素出现在可观察视图内的次数 ，也可以理解为展示量。通常我们会使用 点击量 / 曝光量 得出 点击率 ，作为衡量一个内容是否受用户喜爱的指标之一。比如，曝光 100 次只有 10 人点击，和曝光 100 次 有 100 个人点击，很明显后者更受用户喜爱。利用这些数据参考，可以推荐更多用户喜爱的内容，以此来留住用户。交叉观察者IntersectionObserver 接口，提供了一种异步观察 目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态 的方法，祖先元素与视窗(viewport)被称为根(root)。简单来说就是，观察的目标是否和祖先元素和视窗发生交叉，即进入或离开。小程序从基础库 1.9.3 开始支持 wx.createIntersectionObserver 接口(组件内使用 this.createIntersectionObserver )，使用此接口可创建 IntersectionObserver对象 。对此接口不了解的可以查看 官方文档 。基础使用// 创建实例\r\nlet ob = this.createIntersectionObserver()\r\n// 相对于文档视窗监听\r\nob.relativeToViewport()\r\n    .observe('.box', res => {\r\n        // res.intersectionRatio 为相交比例\r\n        if (res.intersectionRatio > 0) {\r\n            console.log('进入页面')\r\n        } else {\r\n            console.log('离开页面')\r\n        }\r\n    })阈值在创建实例时可以传入一些配置，其中 thresholds （阈值）是比较重要的一项配置，它可以控制触发回调的时机。 thresholds 是一个数字类型的数组，默认为 [0] 。即相交比例为 0 时触发一次回调，下面我们来设置阈值，看看会有什么改变：// 创建实例\r\nlet ob = this.createIntersectionObserver({\r\n    thresholds: [0, 0.5, 1]\r\n})从图上可以看到，元素在相交比例为 0 、 0.5 、 1 都各自触发了一次回调。在统计曝光量设置阈值非常有用，通常我会设置为 1 ，表示元素要完全展示在页面上才会进行记录，这样数据会更加真实准确。收缩和扩展参照区域除了阈值之外还有另一项重要的设置，在使用 relativeTo 或 relativeToViewport 规定参照区域时，我们可以传入配置 margins 来收缩和扩展参照区域。 margins 包括 left 、 right 、 top 、 bottom 四个参数配置。// 创建实例\r\nlet ob = this.createIntersectionObserver()\r\n// 相对于文档视窗监听\r\nob.relativeToViewport({\r\n        bottom: -330\r\n    })\r\n    .observe('.box', res => {\r\n        // res.intersectionRatio 为相交比例\r\n        if (res.intersectionRatio > 0) {\r\n            console.log('进入页面')\r\n        } else {\r\n            console.log('离开页面')\r\n        }\r\n    })上面将参照区域底部收缩 330px，可以理解为整体的区域从底部开始被裁剪 330px，因此元素只有进入页面上半区才会触发回调。进入正题经过以上一些介绍，相信大家对交叉观察者的好处和使用都了解的差不多。接下来进入正题 ~背景此次我做的项目是资讯类目的小程序，主要用于发布和转载一些学术文章。对于这种资讯的项目，需要通过数据埋点来收集用户的阅读习惯，以此来为用户推荐文章。埋点方面用微信后台提供的自定义分析以文章为单位进行收集，而我们自己后台会以用户为单位进行收集。前者得出整体用户阅读偏好和文章热度，后者主要精确到用户，分析用户单位的阅读偏好。改造组件在分析页面布局和pm的商讨后，多处需要统计曝光量的文章区域展示都大致相同，刚好也在封装的列表组件里。于是将收集曝光量的逻辑都交由组件内部处理。组件改造：isObserver\r\nlist\r\n以下部分代码省略，只展示主要逻辑：<block wx:for=\"{{list}}\" wx:key=\"id\">\r\n    <view class=\"artic-item artic-item-{{index}}\" data-id=\"{{item.id}}\" data-index=\"{{index}}\">\r\n    </view>\r\n</block>const app = getApp()\r\nComponent({\r\n    data: {\r\n        currentLen: 0\r\n    }\r\n    properties: {\r\n        list: {\r\n            type: Array,\r\n            value: []\r\n        },\r\n        isObserver: {\r\n            type: Boolean,\r\n            value: false\r\n        }\r\n    },\r\n    observers: {\r\n        list(list) {\r\n            if (this.data.isObserver === false) {\r\n                return\r\n            }\r\n            if (list.length) {\r\n                // currentLen 记录当前列表的长度\r\n                // 用于计算监听元素的索引，对已经监听过的元素不再重复监听\r\n                let currentLen = this.data.currentLen\r\n                for (let i = 0; i < list.length - currentLen; i++) {\r\n                    let ob = this.createIntersectionObserver({\r\n                        thresholds: [1]\r\n                    })\r\n                    ob.relativeToViewport()\r\n                        .observe('.artic-item-' + (currentLen + i), res => {\r\n                            // 获取元素的dataset\r\n                            let {\r\n                                id,\r\n                                index\r\n                            } = res.dataset\r\n                            if (res.intersectionRatio === 1) {\r\n                                // 此处收集曝光量，内部处理逻辑会在下面提及\r\n                                this.sendExsureId(id)\r\n                                // 元素出现后取消观察者监听，避免重复触发\r\n                                ob.disconnect()\r\n                            }\r\n                        })\r\n                }\r\n            }\r\n            this.data.currentLen = list.length\r\n        }\r\n    }\r\n})发现:bug:理想情况应该是切换到第二个分类打印3个文章，但由于组件开始记录第一个分类列表的 currentLen ，在切换到第二个分类时， currentLen 没有被清除，导致循环长度错误。解决：首先记录列表第一项的 id ，当监听列表变化，用新列表的第一项 id 作与之比较。若不相等，则表示列表被重新赋值，此时将 currentLen 置为0。Component({\r\n    data: {\r\n        flagId: 0,\r\n        currentLen: 0\r\n    }\r\n    properties: {\r\n        list: {\r\n            type: Array,\r\n            value: []\r\n        },\r\n        isObserver: {\r\n            type: Boolean,\r\n            value: false\r\n        }\r\n    },\r\n    observers: {\r\n        list(list) {\r\n            if (this.data.isObserver === false) {\r\n                return\r\n            }\r\n            if (list.length) {\r\n                // 比较id\r\n                if (this.data.flagId != list[0].id) {\r\n                    this.data.currentLen = 0\r\n                }\r\n                let currentLen = this.data.currentLen\r\n                for (let i = 0; i < list.length - currentLen; i++) {\r\n                    let ob = this.createIntersectionObserver({\r\n                        thresholds: [1]\r\n                    })\r\n                    ob.relativeToViewport()\r\n                        .observe('.artic-item-' + (currentLen + i), res => {\r\n                            let {\r\n                                id,\r\n                                index\r\n                            } = res.dataset\r\n                            if (res.intersectionRatio === 1) {\r\n                                this.sendExsureId(id)\r\n                                ob.disconnect()\r\n                            }\r\n                        })\r\n                }\r\n            }\r\n            // 设置列表第一项id\r\n            this.data.flagId = list[0] ? list[0].id : 0\r\n            this.data.currentLen = list.length\r\n        }\r\n    }\r\n})组件优化因为需要提前监听文章的相交状态，在 list 传入时就开始循环 observe 。现在假设一个场景，在进入页面时，已经为一些文章注册完成回调，但用户并没有看过这些文章就退出页面。那是不是表示这些实例都没有被 disconnect 。解决：在 observe 时将每一个观察者实例存入数组，当组件销毁时检查数组中是否有观察者实例，如果有，则调用这些实例的 disconnect 。Component({\r\n    data: {\r\n        currentLen: 0,\r\n        obItems: [] // 存放实例的数组\r\n    },\r\n    observers: {\r\n        list(list) {\r\n            if (this.data.isObserver === false) {\r\n                return\r\n            }\r\n            if (list.length) {\r\n                if (this.data.flagId != list[0].id) {\r\n                    this.data.currentLen = 0\r\n                    // 取消实例的监听\r\n                    this.removeObItems()\r\n                }\r\n                let currentLen = this.data.currentLen\r\n                for (let i = 0; i < list.length - currentLen; i++) {\r\n                    let ob = this.createIntersectionObserver({\r\n                        thresholds: [1]\r\n                    })\r\n                    ob.relativeToViewport().observe('.artic-item-' + (currentLen + i), res => {\r\n                        let {\r\n                            index,\r\n                            id\r\n                        } = res.dataset\r\n                        if (res.intersectionRatio === 1) {\r\n                            this.sendExsureId(id)\r\n                            ob.disconnect()\r\n                            // 取消监听后 将实例移出数组\r\n                            this.data.obItems.shift()\r\n                        }\r\n                    })\r\n                    // 将实例存入数组\r\n                    this.data.obItems.push(ob)\r\n                }\r\n            } else {\r\n                // 取消实例的监听\r\n                this.removeObItems()\r\n            }\r\n            this.data.flagId = list[0] ? list[0].id : 0\r\n            this.data.currentLen = list.length\r\n        }\r\n    },\r\n    lifetimes: {\r\n        detached() {\r\n            // 组件销毁时 取消实例的监听\r\n            this.removeObItems()\r\n        }\r\n    },\r\n    methods: {\r\n        removeObItems() {\r\n            if (this.data.obItems.length) {\r\n                this.data.obItems.forEach(ob => {\r\n                    ob.disconnect()\r\n                })\r\n            }\r\n        }\r\n    }\r\n})收集处理现在组件能够收集到曝光文章的ID，剩下的就是往后台发送数据。那么问题来了，难道文章曝光一次就发起一次请求吗？如果不怕和后端同事干架的话，你可以这么做。要知道多次发起请求，服务器:pear:会很大。用户量比较大后，对服务器能够承受的并发量会有很大的考验。所以正确的做法应该是，把收集到的ID缓存起来，在达到一定数量的时候一起发送过去。接下来对收集的数据做些处理：// 这个上面收集曝光量的函数\r\nsendExsureId(id) {\r\n    if (typeof app.globalData.exposureIds === 'undefined') {\r\n        // exposureIds 是定义在全局用于存放曝光文章 ID 的数组\r\n        app.globalData.exposureIds = []\r\n    }\r\n    app.globalData.exposureIds.push(id)\r\n    // 当数组到达 50 个，开始上报数据\r\n    if (app.globalData.exposureIds.length >= 50) {\r\n        wx.$api.recordExposure({\r\n            // 因为 ID 比较多，我和后端约定好使用逗号分隔\r\n            ids: app.globalData.exposureIds.join(',')\r\n        })\r\n        // 上报后清空数组\r\n        app.globalData.exposureIds = []\r\n    }\r\n}看起来好像实现到这里就大功告成，但是我们还要考虑一种情况。假如用户只看了 40 个就退出小程序，而上报条件是达到 50 个才会发送数据，那么这部分有用的数据就会被丢失。因为小程序没有回调能够监听到小程序被销毁，这里只能使用小程序的 onHide 函数来做些事情。当小程序进入后台时 onHide 函数就会被执行，此时可以在函数里上报数据。App({\r\n    onHide() {\r\n        if (this.globalData.exposureIds.length) {\r\n            wx.$api.recordExposure({\r\n                ids: this.globalData.exposureIds.join(',')\r\n            })\r\n            this.globalData.exposureIds = []\r\n        }\r\n    }\r\n})写在最后说实话，在埋点这方面的知识不算很熟悉，业务场景也比较简单。因为没有大佬指导，也是看着需求往这方面去做，有哪里错误或遗漏请指出。如果你有更好的方案或经验，欢迎评论区交流:sparkling_heart:~ \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "写微信小程序这一个月 ", "author": "Rolan", "time": "2020-4-13 00:21", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    最近在做一个微信小程序的项目，遇到了不少坑，不得不说微信小程序的官方文档写的真的不怎么样，一开始技术选型的时候也有考虑过第三方框架，mpvue，uniapp等，但是最后考虑了下，还是先了解一下原生小程序比较好，我始终认为一开始就上第三方框架并不是很好。下面我总结了一些坑点和开发过程中容易遇到的问题。wxss or less对于写惯了less的开发来书，写wxss实在是效率低下，太煎熬了，对此可以使用vscode插件 easy-less 来解决，我是用vscode来写代码，微信开发工具只作预览。网络请求wx.request是小程序的网络请求方法，默认情况下，我们希望success是在服务器响应的状态码在2xx的时候触发，实际上不是，只要网络请求成功发出了，success方法就会触发，比如500状态码也会触发success，所以fail也只在网络请求没有发出的情况下触发，所以你必须在success重复写判断逻辑,而且也不能用promise，所以有必要封装一下// 封装前\r\nwx.request({\r\n  url: 'test.php', //仅为示例，并非真实的接口地址\r\n  data: {\r\n    x: '',\r\n    y: ''\r\n  },\r\n  header: {\r\n    'content-type': 'application/json' // 默认值\r\n  },\r\n  success (res) {\r\n    // 假设服务器的响应体是{success: true, data: 123}\r\n    if (res.statusCode === 2xx) {\r\n        fn(res.data.data)\r\n    } else {\r\n        wx.showToast({            icon: 'none',            title: res.data.message || '网络异常',            duration: 1500        })\r\n    }\r\n  },\r\n  fail (res) {\r\n    console.log(res);\r\n  }\r\n})\r\n\r\n// 封装后\r\n// request.js\r\nmodule.exports = function ({url, data, method}) {    const app = getApp();    return new Promise((resolve, reject) => {        wx.request({            method: method,            url: `${app.globalData.apiUrl}/${url}`,            data: data,            header: {                token: app.globalData.token            },            success: function (res) {                if (res.statusCode === 200) {                    const data = res.data.data;                    resolve(data);                } else if (res.statusCode === 401) {\r\n                    // 登录失效,包含业务逻辑，根据需求添加\r\n                    wx.setStorageSync('token', null); // 清除token                                        app.globalData.token = null;                    wx.setStorageSync('userInfo', {}); // 清除用户数据                    app.globalData.userInfo = {};                    wx.switchTab({                        url: '/pages/user/user'                    });                    reject(res.data);                } else if (res.statusCode >= 500) {                    wx.showToast({                        icon: 'none',                        title: res.data.message || '网络异常',                        duration: 1500                    });                    reject(res.data);                }            },            fail: function () {                wx.showToast({                    icon: 'none',                    title: '网络异常',                    duration: 1500                });            }        });    })}\r\n\r\n// app.js\r\nconst request = require('./utils/request.js');App({    onLaunch: function () {        this.request = request;    },    globalData: {        token: wx.getStorageSync('token'),        userInfo: wx.getStorageSync('userInfo'),        apiUrl: 'http://localhost:3300/api/'            }})// index.js\r\nconst app = getApp();app.request({\r\n   method: 'GET',   url: '/test'}).then(res => {    // do something});复制代码Promise finally因为在某些接口请求前会加loading，防止多次点击，然后在接口的finally中取消loading即可，在开发工具中，一切正常，但是一到真机调试就会报错，查阅资料发现微信小程序不支持promise finally，太坑了，只能加个 polyfill canvas绘图小程序一般都会有分享图片的需求，图片一般都带用户信息和小程序码，这时候就要用到canvas，而原生的canvas是如此难用和坑，所以想使用三方库，一开始试了html2canvas，html2canvas它确实很强大，可以直接获取dom绘制，但是微信小程序无法获取dom，引入之后直接报错，thirdScriptError Cannot read property 'document' of undefined TypeError: Cannot read property 'document' of undefinedhtml2canvas(document.body).then(function(canvas) {\r\n    document.body.appendChild(canvas);\r\n});复制代码Painterpainter可以使用json数据描述绘图，不用繁琐操作canvas的一大坨函数，方便很多，基本能满足需求了。中间遇到一个小问题，开发工具里，绘图后保存到相册是有头像的，但是发小程序正式包后，真机操作时，绘图的头像就会丢失，一开始以为是painter的兼容问题，后来才发现是因为开发工具是开启了不校验合法域名的，但是线上包会校验合法域名，天真的以为微信自己的头像域名不用添加，结果并不是，微信连自己都不放过，在微信小程序后台添加下合法域名就好了 https://wx.qlogo.cn获取小程序码微信有3中方式获取小程序码wxacode.createQRCode获取小程序二维码，适用于需要的码数量较少的业务场景。通过该接口生成的小程序码，永久有效，有数量限制wxacode.get获取小程序码，适用于需要的码数量较少的业务场景。通过该接口生成的小程序码，永久有效，有数量限制wxacode.getUnlimited获取小程序码，适用于需要的码数量极多的业务场景。通过该接口生成的小程序码，永久有效，数量暂无限制好像没有什么理由不选第三种吧这3个接口返回的都是图片Buffer，我们需要做下处理，有2种方式方式1：把图片存到服务器本地或转存到alioss等第三方对象服务器上，最后把地址返回给小程序前端// 服务器\r\nlet readable;\r\nlet filePath = xxx; // 自己创建一个存图片的目录\r\nconst url = `https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=${access_token}`;const result = await axios.post(url, {                scene: `a=${xxx}` // 小程序码带的参数，比如带一个邀请码            }, {                 headers: {                    'Content-Type': 'application/json' // POST 参数需要转成 JSON 字符串，不支持 form 表单提交。                },                responseType: 'arraybuffer'             });            readable = result.data;            readable.pipe(fs.createWriteStream(filePath));复制代码方式2：把Buffer转成base64返回给小程序前端，前端在转成图片存到小程序本地// 服务器\r\nconst url = `https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=${access_token}`;            const result = await axios.post(url, {                scene: `a=${xxx}` // 小程序码带的参数，比如带一个邀请码            }, {                 headers: {                    'Content-Type': 'application/json' // POST 参数需要转成 JSON 字符串，不支持 form 表单提交。                },                responseType: 'arraybuffer'             });            const base64 = Buffer.from(result.data).toString('base64');\r\n            // 返回前端            res.send({                success: true,                data: `data:image/jpg;base64,${base64}`            });\r\n\r\n// 小程序前端\r\n// base64src.js base64转图片存到小程序临时目录中\r\nconst fsm = wx.getFileSystemManager();const FILE_BASE_NAME = 'qrcode_base64src';const base64src = function(base64data) {  return new Promise((resolve, reject) => {    const [, format, bodyData] = /data:image\\/(\\w+);base64,(.*)/.exec(base64data) || [];    if (!format) {      reject(new Error('ERROR_BASE64SRC_PARSE'));    }    const filePath = `${wx.env.USER_DATA_PATH}/${FILE_BASE_NAME}.${format}`;    const buffer = wx.base64ToArrayBuffer(bodyData);    fsm.writeFile({      filePath,      data: buffer,      encoding: 'binary',      success() {        resolve(filePath);      },      fail() {        reject(new Error('ERROR_BASE64SRC_WRITE'));      },    });  });};module.exports = base64src;// index.js\r\nlet base64Data = xxx; // 服务器返回的base64数据base64src(base64Data).then((src) => {                wx.getImageInfo({                    src: src,                    success: function (r) {                        console.log(r.path); // 图片本地路径                    },                    fail: function (r) {                        console.log(r);                    }                });            });\r\n\r\n复制代码自定义组件 behavior有时候某些自定义组件会有大部分的相似功能，小部分差异，这时候可以使用behavior封装共同的属性和方法等，类似vue中的mixins。 \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "开始你的uniapp之旅:写出你的第一个微信小程序 ", "author": "Rolan", "time": "2019-11-18 00:07", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。引用官方介绍 , 为什么它可以做到这点 ? uniapp 内置了 Vue.js 如果你熟悉 Vue.js ,  就知道 Vue 的核心只是完成的只是在数据变更后 , 自动帮你把用到这个数据的 \" 对象 \" 中的数据进行更新 , 在浏览器器上它对应着浏览器 dom , 在不同的平台上它可以对应不同的东西 , 这就赋予了 Vue.js 的跨平台能力刚刚说的\"对象\"并不是 Javascript 中 的 Object , 理解成 面向对象编程中的对象更为合适 , 无论它是虚拟的还是现实中的东西 , 它都可以被描述为对象 . 你可以想象吗, 有人已经把 Vue 移植到了带有显示屏的底层硬件上 , 每当 Vue 代码中的数据更新时 , 显示屏上的数据也会被通知更新 .你知道这点就行了 : uniapp 编译时 , 把 Vue template中的基础组件对应不同平台上的基础组件 ,完成了跨平台的工作 .uniapp 跨平台是不是很多坑?你一定会怀疑 unipp 的能力 . 是的 , 必然是有坑的 . 但是坑的层面不是数据层面 , Javascript引擎在不同平台上的解析都是符合规范的  ,一般是 css 样式 或者 api 层面的 , 每个平台对 css和api 的支持不同 ,这个必须你自己去做兼容 , 再好的编译也不可能完全消除原生上带来的差距 . 因此 , 它的坑并不是因为自身的原因 , 而是你对这个平台本身不是很了解 , 写出了不兼容的代码 .如果你不考虑兼容的话 , 我可以说它写小程序是没有坑的 . 你最后写起来会感觉跟小程序差不多 , 但是写起来更爽 .为什么我一定推荐你用 uniapp 写微信小程序?微信小程序用它的语法写不好吗 ? 为什么一定要用 uniapp 呢 . uniapp有几大优势微信的所有api都可以用Vue 的几乎所有语法的支持内置 Vuex 和 Vue-router可以用浏览器调试其他类似于css动画 , vue单文件的优势就不一一说了 .  加粗的每一点都值得你去使用 uniapp .第一点:用 Vue 来写程序 , 你的 Vue 水平和了解程度也会上升不少 , 将来写网页或者其他东西时候 , 用 Vue 也是胸有成竹 .第二点: 微信小程序没有内置 类似 Vuex 的功能 , 导致跨页面 , 跨多级组件的共享数据会非常麻烦 .第三点: 如果你调试过微信小程序就知道 , 每次修改完后编译是多慢 ,展开 dom 是多么麻烦 , 查看数据只能一个 console.log 或者 debugger 来调试 . 但是用 chrome来调试就完全不同了 , 它编译很快 , 可以用 Vue 官方插件 dev-tool 来 查看 v-node 树 , 数据状态和 Vuex , 这个真的是在开发体验和效率上是**降维打击 . **版本较新的浏览器对 css 的支持是一个超集 , 在小程序中的能使用的样式在 chrome 完全兼容, 调试效率也会高一些 , 不过自定义组件要注意一下 , 它的宽高只能由内部撑起 .uniapp 来写小程序有没有缺点呢?有 .微信限制小程序包的大小为 2mb , 但是 uniapp 编译的小程序因为自带 Vue Vuex 等原因 , 会稍稍多几十kb不过不是特别大的问题 . 2. 首次渲染页面速度不如小程序 . 毕竟是要多一层 Vue 的传递所以, 首次加载不如原生 .但是后续的数值更新 , 特别是大量数据的更新 , 因为 Vue 中有 diff 算法使渲染的效率大大提升 .开启 uniapp 的学习第一步:首先下载安装 hbuiderx(标准版) 和 微信开发者工具第二步: hbuilderx 安装完后安装 uniapp 插件 , 其他的插件 比如 scss 编译 等等也可以安装一下 , 全装也没问题哈第三步:微信开发者工具和 uniapp 都安装完后打开微信开发者工具 , 登录账号等等操作设置服务端口 , 先打开你的微信开发者工具 -> 上栏 -> 设置 -> 安全设置 -> 服务端口 -> 开启接着 hbuilderx导航栏 工具 -> 设置 -> 源码视图 这里可以看到右边有设置的json 找到最后一行-> \"weApp.devTools.path\":\"\" 这里填上微信开发者工具的绝对路径 比如我的 : \"weApp.devTools.path\":\"E:/微信web开发者工具\"第四步:两个都设置完后 , hbuilderx 导航栏左上角:文件 -> 新建 -> 项目 -> 选择 uniapp ->选择模板 : Hello uniapp 演示模板 创建-> 导航栏中间:运行 -> 运行到小程序 , 你就可以啦~接下来的学习可以到官方的文档去学习哦~官方的文档 \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "闲鱼前端基于 serverless 的一种多端开发解决方案 ", "author": "Rolan", "time": "2019-11-18 00:27", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    背景前端的发展太快了，前端框架和技术的发展也层出不穷，还包括不同智能设备的出现，对前端开发同学来说是个很大的跳转，简单列举下：前端框架：vue、react、angular小程序：微信小程序、支付宝小程序、字节跳动小程序智能设备：苹果设备、天猫精灵、小度这样就滋生了一些问题，比如我要开发一个通用的页面，兼容不同的端侧和小程序，显然目前是做不到的，我们只能开发多套页面去适配不同的场景，这样的话成本就太高了。很多同学都在尝试解决这个问题，也催生了类似 taro 这样的多端统一开发框架，这是一个好的解决方案，但是比较被动，缺乏一定的扩展性。这篇文章我们要探讨的是，看能不能换个角度去解决这个问题，提升开发效率。ViewModel当我们在开发一个页面的时候，不管用的是哪一种框架，通常都会抽象出一层 viewmodel 层，它主要有 2 个作用和服务端进行交互，接受后台返回的数据，进行加工并传递给 view 层渲染接受 view 层的回调，加工数据并返回给 view 层渲染从上图中我们可以看出，viewmodel 是一段独立的通用代码逻辑，起到了承前启后的作用。它和 view 层关系更加紧密，因此通常会放在前端测。既然 viewmodel 是独立的，那我们能不能把它放在后端呢？这样一个最大的好处就是 viewmodel 可以进行复用，不需要在重复编写，而且只需要改动一个 viewmodel，就可以全量生效。似乎是一个很美好的想法，但是这部分代码由谁去开发呢，总不可能寄希望于后端同学吧，当然只能是我们自己，也感谢于 serverless 架构的出现，让这件事情变成了可能。有些同学可能会问，既然 viewmodel 后移了，那 view 呢？后续会考虑结合我们的 ui2code 技术，那真的就比较完美了。什么是 serverless我们先简单介绍一下什么是 serverless，serverless 的基础是云技术，它是云技术发展到一定阶段而出现的一种革命性的高端架构。serverless 并不是说不需要服务器，而是指不需要开发者去关心底层服务器的状态、资源和扩容等，开发者只需要关注于业务逻辑实现。架构上，我们可以把 serverless 分为 FaaS 和 BaaS。FaaS 是用于创建、运行、管理函数服务的计算平台，它支持多种开发语言，比如 java、nodejs、dart 等，这有利于不同端侧的开发同学介入开发。FaaS 是基于事件驱动的思想，只有当一个函数被事件触发时才会占用服务器资源执行，不然都是无需占用服务器资源的。BaaS 提供了用于函数调用的第三方基础服务，比如身份校验、日志、数据库等，它是由服务商直接提供，开发者无需关系实现，直接调用即可。业务落地我们是通过 gaia 平台 开发后端接口，gaia 可以理解为上文提到的 FaaS 平台。日常开发中有这样一个需求，下面是这个需求的一个页面。因为这个页面上的数据比较多，先把它切分成一个个小的模块，后台返回数据的时候也根据模块来返回数据。我们是根据 viewmodel 来设计接口，首先肯定有一个首屏数据接口；然后是页面上的交互，比如切换卡片、切换芝麻信用按钮，切换会引起页面数据变化，我们可以统一封装一个页面更新的接口；最后是一个开通的接口。后端接口前后端交互最重要的数据结构的设计，我们省略了中间的业务逻辑处理，看下接口的数据结构。首屏接口返回的数据主要有几个特征：根据前端的页面模块定义返回结构字段的颗粒度很细，页面上的每个元素都对应一个字段值有两个字段来控制模块的显示和刷新更新接口的返回数据结构和首屏接口类似，但是入参有所不同，主要包括 2 个字段：data：当前页面的数据，为了避免数据的重复获取action: 定义的页面操作前端处理从后端返回的数据可以看到，数据是及其详细的，无需我们做任何的业务逻辑处理，直接映射到页面即可。这样，前端已经变成了很薄的一层数据，没有任务的业务逻辑处理，变的很简单，当需要迁移到其他端时，只需要迁移视图层即可。当有任何的业务变动时，只需要修改后端的接口，就能生效。收益与总结通过具体的实践，我们发现，对于前端开发同学来说，变的简单了，开发效率有很大的提升，前端同学甚至都不需要去理解具体的业务逻辑，就能完成页面的开发。而且，提取的 viewmodel 可以复用到不同的端侧，设置还包括 native 端。我们还可以将 viewmodel 拆分成更小粒度的 viewmodel，方便在不同的页面接口中进行复用。我们有同学还在 FaaS 侧基于 redux 的思想封装了一个通用的状态管理框架，规范了前后端的交互。后面， 还有一些问题待我们去解决，比如开发成本、viewmodel 的逻辑拆分、具体接口问题定位等。本文转载自公众号闲鱼技术（ID：XYtech_Alibaba）。原文链接：https://mp.weixin.qq.com/s/VLsVTe4ZyOJ9rNyVf5aXyg \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "小程序 swiper 如何多页面高度自适应 ", "author": "Rolan", "time": "2019-11-18 00:40", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    轮播，这个概念只要做过 UI 的都不会陌生，盲猜市场上 90% 的应用都有这个需求，在 iOS 和 Android 上都有很完善的控件，比如 Android 的 ViewPager 和 iOS 的 UIScrollview。\r\n\r\n小程序这么牛逼，肯定也要有控件支持这个特性啊， swiper 就这么诞生了。\r\n但是 swiper 有一个很严重的问题，就是高度默认 150px，且不可以自适应内容调整高度。\r\n这就有问题了，我现在有一个多 Tab 的页面，最少高度要满屏，还要超出内容可以往下滚动，此时就蒙蔽了，怎么给 swiper 设置高度呢？\r\n首先看一下我搜索到的一些方法：\r\n\r\n\r\n在初始化的时候获取到屏幕的高度，然后将高度设置到 swiper 上，至于滚动的问题，在里面再嵌入一个 scroll-view\r\n这个问题有很多坑，首先 屏幕的高度要比内容区的高度大，这么设置以后就算内容较少，页面也能滑动一点；其次，小程序的 scroll-view 在实现上拉加载更多的时候，坑更多。\r\n\r\n\r\n每个 item 的高度都一致，根据 item 的数量和统一的高度计算出内容的高度，然后设置进去\r\n这个方案感觉完全是 zz 方案，局限性太大了\r\n\r\n\r\n我的方案\r\n\r\n一句话解释：给 swiper-item 内部添加三个锚点，最上面一个，最下面一个，还有一个锚点始终位于屏幕最底下。根据这三个锚点计算出内容高度和内容显示区高度。\r\nPS：锚点，宽高为 0 的不可见的 view，用于获取定位\r\n\r\n如果还有不理解可以看下面这个示意图：\r\n\r\n这三个锚点的具体作用是用来计算 swiper 内容高度和 swiper 距离屏幕底部的具体，计算方式如下：\r\n\r\n使用 swiper-item 内部的两个锚点计算出内容区高度\r\n通过屏幕底部和 swiper-item 顶部的锚点计算出离屏幕底部的距离\r\n\r\n接下来看看代码具体实现\r\n代码实现\r\npage.wxml\r\n<view>\r\n\t<swiper style=\"height: {{anchor.deviceHeight + 'px'}}\">\r\n\t\t<swiper-item>\r\n\t\t\t<view class=\"anchor-top\"></view>\r\n\t\t\t<!-- 你的内容 -->\r\n\t\t\t<view class=\"anchor-bottom\"></view>\r\n\t\t</swiper-item>\r\n\t</swiper>\r\n\t<view class=\"anchor-screen-bottom\"></view>\r\n</view>\r\n复制代码\r\npage.wxss\r\n.anchor-top {\r\n    width: 0;\r\n    height: 0;\r\n}\r\n\r\n.anchor-bottom {\r\n    width: 0;\r\n    height: 0;\r\n}\r\n\r\n.anchor-screen-bottom {\r\n    position: absolute;\r\n    bottom: 0;\r\n    width: 0;\r\n    height: 0;\r\n}\r\n复制代码\r\npage.js\r\nPage({\r\n\tdata: {\r\n\t\tanchor: {\r\n\t\t\tdeviceHeight: 0,\r\n      anchorTop: 0,\r\n      anchorBottom: 0,\r\n      anchorScreenBottom: 0\r\n\t\t}\r\n\t},\r\n\tonReady: function() {\r\n\t\tthis.computeSwiperHeight(0)\r\n\t},\r\n\tcomputeSwiperHeight(pageIndex) {\r\n\t  let getSwiperHeight = () => {\r\n      let min = this.data.anchor.anchorScreenBottom - this.data.anchor.anchorTop;\r\n      let value = this.data.anchor.anchorBottom - this.data.anchor.anchorTop\r\n      return Math.max(min, value)\r\n\t  }\r\n\t  wx.createSelectorQuery()\r\n      .select('.anchor-screen-bottom')\r\n      .boundingClientRect()\r\n      .selectViewport()\r\n      .scrollOffset()\r\n      .exec(res => {\r\n        this.data.anchor.anchorScreenBottom = res[0].bottom\r\n      })\r\n\t  wx.createSelectorQuery()\r\n      .selectAll('.anchor-top')\r\n      .boundingClientRect()\r\n      .selectViewport()\r\n      .scrollOffset()\r\n      .exec(res => {\r\n        this.data.anchor.anchorTop = res[0].top\r\n        this.setData({\r\n          'anchor.deviceHeight': getSwiperHeight()\r\n        })\r\n      })\r\n\t  wx.createSelectorQuery()\r\n      .selectAll('.anchor-bottom')\r\n      .boundingClientRect()\r\n      .selectViewport()\r\n      .scrollOffset()\r\n      .exec(res => {\r\n        this.data.anchor.anchorBottom = res[0].bottom\r\n        this.setData({\r\n          'anchor.deviceHeight': getSwiperHeight()\r\n        })\r\n      })\r\n\t},\r\n})\r\n复制代码\r\n适配多页面\r\n当然，肯定要适配每个页面的高度不一样的情况。方案也很简单，屏幕底部的锚只需要一个了，给每个 swiper-item 的都添加两个锚点，和之前一样一个在上面一个在下面，在切换页面的时候，根据当前页面的锚点重新计算一下高度，然后设置进去。\r\n只需要在原有基础上改一下代码：\r\npage.wxml\r\n<view>\r\n\t<swiper style=\"height: {{anchor.deviceHeight + 'px'}}\" bindchange=\"swiperChange\">\r\n\t\t<swiper-item>\r\n\t\t\t<view class=\"anchor-top\"></view>\r\n\t\t\t<!-- 你的内容 -->\r\n\t\t\t<view class=\"anchor-bottom\"></view>\r\n\t\t</swiper-item>\r\n\t\t<swiper-item>\r\n\t\t\t<view class=\"anchor-top\"></view>\r\n\t\t\t<!-- 你的内容 -->\r\n\t\t\t<view class=\"anchor-bottom\"></view>\r\n\t\t</swiper-item>\r\n\t</swiper>\r\n\t<view class=\"anchor-screen-bottom\"></view>\r\n</view>\r\n复制代码\r\npage.wxss\r\nCSS 不需要改动\r\npage.js\r\nPage({\r\n\tdata: {\r\n\t\tanchor: {\r\n\t\t\tdeviceHeight: 0,\r\n      anchorTop: 0,\r\n      anchorBottom: 0,\r\n      anchorScreenBottom: 0\r\n\t\t}\r\n\t},\r\n\tonReady: function() {\r\n\t\tthis.computeSwiperHeight(0)\r\n\t},\r\n\tswiperChange(e) {\r\n    this.computeSwiperHeight(e.detail.current)\r\n  },\r\n\tcomputeSwiperHeight(pageIndex) {\r\n\t  let getSwiperHeight = () => {\r\n      let min = this.data.anchor.anchorScreenBottom - this.data.anchor.anchorTop;\r\n      let value = this.data.anchor.anchorBottom - this.data.anchor.anchorTop\r\n      return Math.max(min, value)\r\n\t  }\r\n\t  wx.createSelectorQuery()\r\n      .select('.anchor-screen-bottom')\r\n      .boundingClientRect()\r\n      .selectViewport()\r\n      .scrollOffset()\r\n      .exec(res => {\r\n        this.data.anchor.anchorScreenBottom = res[0].bottom\r\n      })\r\n\t  wx.createSelectorQuery()\r\n      .selectAll('.anchor-top')\r\n      .boundingClientRect()\r\n      .selectViewport()\r\n      .scrollOffset()\r\n      .exec(res => {\r\n        this.data.anchor.anchorTop = res[0][pageIndex].top\r\n        this.setData({\r\n          'anchor.deviceHeight': getSwiperHeight()\r\n        })\r\n      })\r\n\t  wx.createSelectorQuery()\r\n      .selectAll('.anchor-bottom')\r\n      .boundingClientRect()\r\n      .selectViewport()\r\n      .scrollOffset()\r\n      .exec(res => {\r\n        this.data.anchor.anchorBottom = res[0][pageIndex].bottom\r\n        this.setData({\r\n          'anchor.deviceHeight': getSwiperHeight()\r\n        })\r\n      })\r\n\t},\r\n})\r\n复制代码\r\n实现效果\r\n\r\nswiper 的高度高度根据内容自适应\r\nswiper 的高度最小占满屏幕，最大和内容一样高（为了用户滑动体验（如果划页后高度突然变小，用户在原来的位置就划不回去了）\r\n适配不同高度的页面\r\n\r\n这个方案是了实现为自己的需求而写的，应该不适应全部的场景，不过希望可以为你提供一点思路。\r\n感想\r\n小程序里的坑真的很多，而且有些 API 设计的很奇怪，真的不知道当初开发人员怀着怎样的心路历程设计出的 API。\r\n个人感觉小程序就是给前端新造了一个轮子，更新还很不及时，有很多陈年老 Bug，比如本文讲的 swiper。\r\n前端娱乐圈发展这么快，感觉小程序可能会跟不上潮流。\r\n最后\r\n给我正在开发的小程序预热一下～\r\n\r\n欢迎关注～ \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "云开发如何实现管理员通知消息 ", "author": "Rolan", "time": "2019-11-19 00:03", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    需求描述小程序目前的主要能力还都在小程序端实现，但是我们在进行开发的小程序不可能只有小程序端能力，我们也会有一些管理端能力。比如说，当用户在小程序中提交了消息以后，我们的小程序应该可以通知到小程序的管理员，以便让管理员进行下一步操作。解决方案架构说明由于小程序本身不支持长久性的消息通知能力，因此，我们可以考虑借助一些第三方的服务和能力，来完成我们自己的需求。这个需求很适合使用小程序新发布的 长期订阅消息 能力，但是目前该能力开放的类目还不足以支持我们的需要。一般而言，使用短信是我们目前到达率比较高的能力，且更为普遍的能力，其他通道的能力大多受限或不符合国情，为了确保通知信息的到达率，我们这篇文章就使用短信来完成需求。架构图示具体操作1. 开通腾讯云短信服务并获取配置信息我们想要发送短信，就需要先有一个短信服务，用于发送短信，这里我们可以使用腾讯云提供的云短信服务来发送短信。开通腾讯云短信，并创建应用首先，你需要访问 https://console.cloud.tencent... ,点击开通腾讯云·云短信。在开通完成后，点击界面中的【 添加应用 】，添加一个新的短信应用，你可以根据自己的实际情况，添加短信应用的名称和简介。获取 AppID、App Key添加完成后，点击你创建好的应用，进入到应用详情页,在应用的详情页中的应用信息栏目中，你可以找到 AppID 和 AppKey ，复制并保存这两个值，稍候我们会用到。2. 配置短信模板、短信签名开通了腾讯云短信服务以后，我们需要去创建短信模板，以及短信签名短信签名则是原来让收到短信的用户知道他所收到的短信来自于他的那一个服务，一般来说，设置为产品的品名。在腾讯云控制台中，进入到【云短信】控制台创建短信签名首先，点击【 国内短信 】，进入到短信的页面，点击【 创建签名 】，然后在弹出的窗口中输入你的签名的具体信息，比如这里我就是以公众号【程序百晓生】来创建签名。签名创建完成后，你需要等待腾讯云官方的审核，审核通过以后，你添加的签名才可以被使用。创建短信模板创建完签名，你需要创建一个短信的正文模板，用于发送短信。输入模板名称、短信类型，然后选择标准模板中的模板，这里我们选择“您有新的{1}订单，请注意查收！”这个模板。除了使用标准模板，你也可以自己编写一个模板，为了方便文章撰写，这里使用标准模板。然后点击提交，等待审核就可以了。3.编写云函数发送短信在完成了基础的配置后，我们在微信开发者工具中实现一个云函数，用于调用腾讯云的短信服务，实现具体的通知。首先，我们创建一个新的云函数，名为 notifyAdmin ，意为用于通知管理员的云函数。然后，选择我们刚刚创建的 notifyAdmin 云函数，在函数上右击，选择【在终端中打开】，进入到控制台，并输入如下命令，安装所需的短信 SDK。npm install --save sms-node-sdk然后，修改云函数的 index.js ，加入如下代码// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\nconst {\r\n  SmsClient\r\n} = require('sms-node-sdk');\r\n\r\n\r\nconst AppID = 1400286810;  // SDK AppID是1400开头\r\n\r\n// 短信应用SDK AppKey ，替换为你自己的 AppKey\r\nconst AppKey = 'xxxx';\r\n\r\n// 需要发送短信的手机号码\r\nconst phoneNumber = '10000000';\r\n\r\n// 短信模板ID，需要在短信应用中申请\r\nconst templId = 476457;\r\n// 签名，替换为你自己申请的签名\r\nconst smsSign = '程序百晓生';\r\n\r\n// 实例化smsClient\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  let orderId = event.orderId;\r\n  let smsClient = new SmsClient({ AppID, AppKey });\r\n  return await smsClient.init({\r\n    action: 'SmsSingleSendTemplate',\r\n    data: {\r\n      nationCode: '86',\r\n      phoneNumber,\r\n      templId: templId,\r\n      params: [orderId],\r\n      sign: smsSign // 签名参数未提供或者为空时，会使用默认签名发送短信\r\n    }\r\n  })\r\n}完成代码的修改后，就可以部署你的云函数了，右键你的云函数，选择【上传并部署云函数：云端安装依赖】4. 在小程序端触发短信在前面我们提到，在一些特定的场景下，我们希望用户的操作可以给管理员发送消息通知。在具体的实现的时候，我们可以根据自己的实际业务需求，来设定我们的通知发送的条件，比如说，在用户支付成功后发送消息，则相关代码如下：let orderId = 'this is a orderId';\r\nwx.requestPayment({\r\n    success:res => {\r\n        console.log(\"User Payment Success\");\r\n        // 调用云函数发送短信\r\n        wx.cloud.callFunction({\r\n            name:\"notifyAdmin\",\r\n            data:{\r\n                orderId: orderId\r\n            }\r\n        });\r\n    }\r\n})总结经过本次的分享，我们了解到了如何借助短信服务，实现云开发的后台通知能力，实际上，除了短信服务，你还可以借助一些其他的工具，比如邮件、企业微信机器人等能力，实现后台管理信息的推送。明天，我们将分享 如何借助通过微信发送订单消息 。 \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "uni-app微信小程序开发之引入腾讯视频小程序播放插件 ", "author": "Rolan", "time": "2019-12-17 00:01", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    目录导航：登录微信小程序管理后台添加腾讯视频播放插件： 在uni-app中引入插件代码：指定整个小程序可使用：指定到对应的分包中使用：在pages.json全局配置文件中对要使用插件的页面配置如下条件编译代码：　　 在.vue页面中使用腾讯视频播放组件：关于如何获取腾讯视频vid问题： 参考资料：腾讯视频小程序播放插件开发文档：decloud uni-app相关配置：微信小程序特有配置: 文章正文：回到顶部登录微信小程序管理后台添加腾讯视频播放插件：　　正式开始使用腾讯视频小程序插件之前需先在微信公众平台 -> 第三方设置 -> 插件管理处添加插件，如下图所示：回到顶部 在uni-app中引入插件代码：　　注意在使用uni-app开发微信小程序时与直接会用微信网页开发工具开发微信小程序是有很大的差别的，因为uni-app可开发多平台的原因，因此不同平台的开发相应的配置需要放到指定的位置才能够生效。而uni-app引入腾讯视频小程序有两种方式一种是整个小程序可使用（小程序中所有的分包可以使用），第二种是指定对应的分包可使用。指定整个小程序可使用：使用插件之前需要在manifest.json中的mp-weixin内声明使用的插件，具体配置参照所用插件的开发文档：1234567891011\"mp-weixin\": {        /* 小程序相关配置 */        \"usingComponents\": true,//是否启用自定义组件模式        \"appid\": \"小程序AppID\",        \"plugins\": {            \"tencentvideo\": {                \"version\": \"1.3.6\",                \"provider\": \"腾讯视频小程序AppID\"            }        }    }指定到对应的分包中使用：如果插件只在（同一个插件不能被多个分包同时引用）一个分包用到，可以单独配置到分包中，这样插件不会随主包加载，可以在pages.json的subPackages中声明插件：1234567891011121314151617{  \"subpackages\": [    {      \"root\": \"package1\",//分包名称      \"pages\": [        \"pages/cat\",        \"pages/dog\"      ],      \"plugins\": {        \"tencentvideo\": {          \"version\": \"1.3.6\",          \"provider\": \"腾讯视频小程序AppID\"        }      }    }  ]}　　回到顶部在pages.json全局配置文件中对要使用插件的页面配置如下条件编译代码：　　12345\"usingComponents\": {    // #ifdef  MP-WEIXIN       \"txv-video\": \"plugin://tencentvideo/video\"    // #endif},回到顶部 在.vue页面中使用腾讯视频播放组件：123456789101112131415<view>           <!--vid中的腾讯视频id最好为动态的数据，方便管理-->          <txv-video :vid=\"VideoId\" playerid=\"txv1\"></txv-video></view>  <script>export default {    data() {        return {            VideoId:'c3029q7tdnp'        };    }}</script>　　　回到顶部关于如何获取腾讯视频vid问题：打开网页腾讯视频=>随便找到一个视频点击鼠标右键=>赋值链接地址（仅供参考）如下图所示：  最后取视频连接地址.html前面的那一小串英文数字编号即可，下图所示：回到顶部 参考资料：腾讯视频小程序播放插件开发文档：https://mp.weixin.qq.com/wxopen/plugindevdoc?appid=wxa75efa648b60994b&token=&lang=zh_CNdecloud uni-app相关配置：https://uniapp.dcloud.io/component/mp-weixin-plugin微信小程序特有配置:https://uniapp.dcloud.io/collocation/manifest?id=mp-weixin \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "微信小程序开发中 var that =this的用法 ", "author": "Rolan", "time": "2020-2-6 00:52", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    在微信小程序开发中，var that =this的声明很常见。举个例子，代码如下！示例代码11  //index.js  \r\n2  Page({  \r\n3   \r\n4   data: {  \r\n5    toastHidden: true,  \r\n6   },  \r\n7   \r\n8   loadData: function () {  \r\n9      var that = this//这里声明了that；将this存在that里面  \r\n10     wx.request({  \r\n11       url: 'test.php',  \r\n12       data: {a: 'a', b: 'b'},  \r\n13       header: {  \r\n14        'content-type': 'application/json'  \r\n15       },  \r\n16       success(res) {  \r\n17           that.setData({ toastHidden: false }) //这里使用了that，这样就可以获取Page({})对象  \r\n18        },  \r\n19      })  \r\n20    }  \r\n21  \r\n22  })在代码中第9行声明了var that =this；第17行使用了that。如果不声明var that =this，且that改成this，代码如下！示例代码21  //index.js  \r\n2   Page({  \r\n3  \r\n4    data: {  \r\n5     toastHidden: true,  \r\n6   },  \r\n7  \r\n8    loadData: function () {  \r\n9      wx.request({  \r\n10      url: 'test.php',  \r\n11      data: {a: 'a', b: 'b'},  \r\n12      header: {  \r\n13       'content-type': 'application/json'  \r\n14      },  \r\n15      success(res) {  \r\n16        this.setData({ toastHidden: false })  \r\n17       },  \r\n18      })  \r\n19   }  \r\n20  \r\n21  })此时运行代码就会报以下错误！从报错中得知setData这个属性读不到，为何读不到？这跟this关键字的作用域有关！this作用域分析：1.在Page({})里面，this关键字指代Page({})整个对象2.因此可以通过this关键字访问或者重新设置Page({})里data的变量3.然而在loadData函数中使用了wx.request({})API这个方法导致在wx.request({})里没办法使用this来获取Page({})对象4.虽然在wx.request({})里没法使用this获取Page({})对象，但是可以在wx.request({})外面先把this存在某个变量中，所以就有了var that =this 这个声明。此时that指代Page({})整个对象，这样子就可以在wx.request({})里使用that访问或者重新设置Page({})里data的变量 \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
{"title": "微信小程序开发中的http请求总结 ", "author": "Rolan", "time": "2020-3-24 00:41", "content": "帐号自动登录 找回密码密码登录 立即注册搜索搜索 \n                     \n                    在微信小程序进行网络通信，只能和指定的域名进行通信，微信小程序包括四种类型的网络请求。普通HTTPS请求(wx.request)上传文件(wx.uploadFile)下载文件(wx.downloadFile)WebSocket通信(wx.connectSocket)这里以介绍 wx.request , wx.uploadFile , wx.dowloadFile 三种网络请求为主设置域名要微信小程序进行网络通信，必须先设置域名，不然会出现错误:URL 域名不合法，请在 mp 后台配置后重试需要在微信公众平台的小程序中设置域名。在微信小程序的 设置界面 可以看到设置选项：选择 开发设置 ：开发设置可以看到服务器设置:服务器设置在这里可以设置对应四种网络访问的域名，每一种类型的网络请求需要设置一个域名，注意如果在这里设置域名为 https://example.com/api/ ,那么 https://example.com/api 是无法调用的，必须加上后面 / 。http请求使用 wx.request 可以发起一个http请求，一个微信小程序被限制为同时只有5个网络请求。function queryRequest(data){    \r\n    wx.request({\r\n        url:\"https://example.com/api/\",\r\n        data:data,\r\n        header:{\r\n           // \"Content-Type\":\"application/json\"\r\n        },\r\n        success:function(res){\r\n            console.log(res.data)\r\n        },\r\n        fail:function(err){\r\n            console.log(err)\r\n        }\r\n\r\n    })\r\n\r\n}\r\n上面的代码会发送一个http get请求，然后打印出返回的结果。其中的参数也比较容易理解。url  服务器的url地址data  请求的参数可以采用String  data:\"xxx=xxx&xxx=xxx\" 的形式或者Object  data:{\"userId\":1} 的形式header  设置请求的headersuccess  接口成功的回调fail  接口失败的回调另外还有两个参数没有在代码里:method\r\ncomplete\r\n上传文件上传文件的api为 wx.uploadFile ，该api会发起一个 http post 请求，其中的 Content-type为 multipart/form-data 。服务器端需要按照该 Content-type 类型接收文件,示例代码：function uploadFile(file,data) {\r\n    wx.uploadFile({\r\n        url: 'http://example.com/upload',\r\n        filePath: file,\r\n        name: 'file',\r\n        formData:data,\r\n        success:function(res){\r\n            console.log(res.data)\r\n        },\r\n        fail:function(err){\r\n            console.log(err)\r\n        }\r\n\r\n    })\r\n\r\n}\r\n其中的 url ， header ， success ， fail 以及 complete 和普通的http请求是一样的。这里有区别的参数是:name 文件对应的key，服务器端需要通过 name 参数获取文件formData  http请求中可以使用的其他参数下载文件下载文件的api为 wx.downloadFile ,该api会发起一个http get请求，并在下载成功之后返回文件的临时路径，示例代码：function downloadFile(url,typ,success){\r\n    wx.downloadFile({\r\n        url:url,\r\n        type:typ,\r\n        success:function(res){\r\n            if(success){\r\n                success(res.tempFilePath)\r\n            }\r\n        },\r\n        fail:function(err){\r\n            console.log(err)\r\n        }\r\n    })\r\n}\r\n其中的 url , header , fail , complete 和 wx.uploadFile 的参数使用是一致的，其中有区别的参数是:type :下载资源的类型，用于客户端自动识别，可以使用的参数 image/audio/videosuccess ：下载成功之后的回调，以 tempFilePath 的参数返回文件的临时目录： res={tempFilePath:'文件路径'} 下载成功后的是临时文件，只会在程序本次运行期间可以使用，如果需要持久的保存，需要调用方法 wx.saveFile 主动持久化文件，实例代码:function svaeFile(tempFile,success){\r\n  wx.saveFile({\r\n      tempFilePath:tempFile,\r\n      success:function(res){\r\n          var svaedFile=res.savedFilePath\r\n          if(success){\r\n              success(svaeFile)\r\n          }\r\n      }\r\n  })\r\n}使用 wx.saveFile 保存临时文件到本地，提供给小程序下次启动时使用，其中的参数：tempFilePath 需要被保存文件的路径success  保存成功的回调，返回保存成功的路径，使用 res.savedFilePath 可以获取保存成功的路径fail  失败的回调complete 结束的回调超时的设置app.js中调整设置：\r\n\r\n\"networkTimeout\":{\r\n   \"request\": 10000,\r\n   \"connectSocket\": 10000,\r\n   \"uploadFile\": 10000,\r\n   \"downloadFile\": 10000\r\n}\r\n这里设置的超时时间对应着四种类型的网络请求。 \r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n                鸡蛋"}
